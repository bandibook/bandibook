> ch7에서 나온 패턴들을 예제 위주로 살펴봅니다.

## 모듈 패턴

TL;DR

- 캡슐화
- 외부에서 접근할 수 있는 공개 메서드만 제공
- 내부 상태를 보호하면서 필요한 기능만 외부에 노출하는 것이 가능
- 내부에서 사용할 것들은 내보내지 않고, 내보낼 것만 `export` 하거나 `return` 하는 것을 떠올릴 수 있다.
- JS에서는 모듈에서 일부만 `export`, React에서는 커스텀 훅에서 선택적으로 상태나 관련 메서드 혹은 업데이트 함수만을 `return` 하는 것이 대표적인 듯

  ```
  💡 캡슐화
  데이터(상태)와 그 데이터를 조작하는 메서드를 하나의 단위로 묶고,
  외부에서 직접 접근할 수 없도록 제한하는 것

  → 불필요한 정보는 숨기고 필요한 정보만 외부에 노출하는 것이 핵심
  ```

👇 JavaScript 클래스 활용

- 만들어 놓을 기능(메서드)들이 내부에서 관리되는 필드를 기준으로 돌아간다면
- 그리고 이 필드가 외부에 공개될 필요가 없다면, 클래스 + 모듈 패턴 조합을 사용할 듯

아래는 최근에 실제로 작성한 코드다. (알고보니 모듈 패턴이였던 것..?)

```ts
import { cookies } from 'next/headers';

const isProduction = process.env.NODE_ENV === 'production';
const ACCESS_TOKEN = 'access_token';

export class CookieModule {
  private cookieStore: ReturnType<typeof cookies>;

  constructor() {
    this.cookieStore = cookies();
  }

  getAccessToken() {
    return this.cookieStore.get(ACCESS_TOKEN)?.value;
  }

  setAccessToken(token: string) {
    this.cookieStore.set({
      name: ACCESS_TOKEN,
      value: token,
      httpOnly: true,
      secure: isProduction,
      sameSite: 'lax',
    });
  }
}
```

👇 JavaScript에서 export

- 내보내기를 원하는 변수나 함수만을 export하고
- 해당 모듈에서 사용할 것들은 export하지 않는 것

```ts
// 내부에서만 사용하는 함수 -> export하지 않는다. (공개 X)
const logOperation = (operation: string, result: number) => {
  console.log(`Operation: ${operation}, Result: ${result}`);
};

export const add = (a: number, b: number) => {
  const result = a + b;
  logOperation('Addition', result);
  return result;
};

export const subtract = (a: number, b: number) => {
  const result = a - b;
  logOperation('Subtraction', result);
  return result;
};
```

👇 React에서 커스텀 훅

- 커스텀 훅을 구현할 때 노출할 상태나 업데이트 함수만을 선택적으로 `return`으로 내보내기 처리
- 내부에서 사용하는 정보들은 노출하지 않음

```ts
export const useCounter = (initialValue = 0) => {
  const [counter, setCounter] = useState(initialValue);

  const increment = () => setCount(count + 1);
  const decrement = () => setCount(count - 1);
  const reset = () => setCount(initialValue);

  return { count, increment, decrement, reset };
};
```

## 싱글톤 패턴

TL;DR

- 인스턴스 딱 하나만 존재, 모두가 공유해서 쓰기

🤔 `import`해서 쓰는 것으로 어느정도는 대체할 수 있지 않을까?

- 사실 싱글톤으로 구현하지 않아도
- 인스턴스를 하나 만들고, 이 인스턴스의 참조값을 `export/import` 해서 사용하면
- 싱글톤을 따로 구현하지 않아도, 계속해서 동일한 참조값으로 사용할 수 있다.
- 겉으로 보았을 때는 인스턴스를 계속 생성하는 것처럼 보이지만 내부에서 존재하는 인스턴스를 리턴해서 처리해주는 것이므로
- 오히려, 참조값을 `import` 하는 것이 좀 더 자연스럽게 느껴졌다.

👇 Why is the singleton such a favorite design pattern among front-end developers?

> https://www.quora.com/Why-is-the-singleton-such-a-favorite-design-pattern-among-front-end-developers

- 패턴이란 게 반복되는 문제와 주제에 적용할 수 있는 재사용 가능한 템플릿이라고 생각한다.
- 억지로 싱글톤을 적용하려고 하는 게 아니라, 필수적으로 싱글톤 패턴이 필요할 때 사용하면 되겠다.

## 프로토타입 패턴

TL;DR

- 여러 객체들이 같은 프로퍼티를 가져야 하는 경우 유용
- 중복되는 프로퍼티들이 존재할 경우 매번 생성해주는 것이 아니라 프로토타입을 통해 인스턴스들이 활용할 수 있도록

👇 ES6 클래스를 사용하면, 메서드가 prototype으로 추가

<p align="center">
  <img width={400} src="https://github.com/user-attachments/assets/15f9037e-8df6-4178-bd1d-078c952de134" />
</p>

클래스의 `prototype` 프로퍼티 혹은 인스턴스의 `__proto__` 프로퍼티를 통해 `Prototype` 객체를 확인할 수 있다.

```ts
console.log(Dog.prototype);
// constructor: ƒ Dog(name, breed) bark: ƒ bark()

console.log(dog1.__proto__);
// constructor: ƒ Dog(name, breed) bark: ƒ bark()
```

<img src="https://patterns-dev-kr.github.io/_astro/prototype01.CktbhN9T_1N3YTE.webp" />

🤔 ES6 클래스를 사용하는 것 자체가 프로토타입 패턴을 사용하는 것으로 느껴졌다

아래는 GPT의 대답

<p align="center">
  <img src="https://github.com/user-attachments/assets/01c98a20-b7a1-4944-a24c-ff649bdbc34d" width={500} />
</p>

## 팩토리 패턴

## 퍼사드 패턴

## 믹스인 패턴

## 데코레이터 패턴

## 플라이웨이트 패턴

## 관찰자 패턴

## 중재자 패턴

## 커맨드 패턴
