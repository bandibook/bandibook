## 12.1 웹사이트와 성능

- 웹사이트에 접속했을 때 공통적으로 기대하는 사항
  1. 웹사이트를 방문한 목적을 손쉽게 달성 가능
  2. 빨리
  3. 보안
- 위 3가지만 달성할 수 있다면, 내부적으로 어떤 코드로 이루어졌는지는 고객들에게 전혀 중요X
- 성능은 다음과 같은 요소에 영향을 미친다
  - 1초 내로 로딩되느 사이트는 5초 내로 로딩되는 사이트보다 전자상거래 전환율이 2.5배 더 높다
  - 0~5초의 범위에서, 1초 로딩이 늦어질수록 전환율을 4.42%씩 떨어진다. 즉 5초 이상 느려지면 전환율을 20% 가까이 떨어진다
  - 페이지 로드 시간이 0~2초 사이인 페이지에서 가장 높은 전환율을 달성할 수 있다
- 그리고 사용자는 이러한 성능에 매우 민감한 것으로 밝혀졌다
  - 소비자의 70%는 페이지 속도가 온라인 커머스 사이트를 방문하는 데 영향을 미친다고
  - 절반 가까운 사람이 더욱 빠르게 로딩할 수 있다면 애니메이션과 동영상이 필요 없다고 밝혔다

## 12.2 핵심 웹 지표란?

- 구글에서 만든 지표
- 웹사이트에서 뛰어난 사용자 경험을 제공하는 데 필수적인 지표
- 구글에서 핵심 웹 지표로 꼽는 지표는
  - 최대 콘텐츠풀 페인트(LCP: Largest Contentful Paint)
  - 최초 입력 지연(FID: First Input Delay)
  - 누적 레이아웃 이동(CLS: Cumulative Layout Shift)
- 그리고 다음 두 지표는 핵심까지는 아니지만, 특정 문제를 진단하는 데 사용될 수 있다고 언급
  - 최초 바이트까지의 시간(TTFB: Time To First Byte)
  - 최초 콘텐츠풀 시간(FCP: First Contetnful Patnt)

## 12.3 최대 콘텐츠풀 페인트(LCP)

### 12.3.1 정의

```
💡 페이지가 처음으로 로드를 시작한 시점부터 뷰포트 내부에서 가장 큰 이미지 또는 텍스트를 렌더링하는 데 걸리는 시간
```

- 뷰포트는 사용자에게 현재 노출되는 화면을 의미
- 뷰포트 내부에서 **큰 이미지와 텍스트**는 다음과 같이 정의
  - `<img>`
  - `<svg>` 내부의 `<image>`
  - url()을 통해 불러온 배경 이미지가 있는 요소
  - 텍스트와 같이 인라인 텍스트 요소를 포함하고 있는 블록 레벨 요소
- 사용자의 기기가 노출하는 뷰포트 내부에서 **가장 큰 영역을 차지하는 요소가 렌더링되는 데 얼마나 걸리는지**를 측정하는 지표
- 실제 크기가 크다고 하더라도 뷰포트 영역 밖에 넘치는 요소가 있다면, 해당 영역의 크기는 고려 X
- 아무리 콘텐츠 높이가 길어도, 최대 콘텐츠풀 페인트에 영향을 미치는 부분은 오직 뷰포트 영역뿐

### 12.3.2 의미

- 웹페이지가 로딩이 완료되어 사용자에게 노출되기까지 걸리는 시간을 측정할 때 기준
- 사용자가 페이지가 어느정도 로딩되었다고 인식하는 시점
- 사용자에게 페이지의 정보를 화면에 전달하는 속도를 객관적으로 판단하기 위한 지표로 만들어진 것

### 12.3.5 개선 방안

#### 텍스트는 언제나 옳다

- 최대 콘텐츠풀 페인트 지표에서 좋은 점수를 얻는 가장 확실한 방법
- 뷰포트 최대 영역, 즉, 최대 콘텐츠풀 페인트 예상 영역에 이미지가 아닌 문자열을 넣는 것
- 아무리 최적화를 하더라도 다운로드가 필요한 이미지보다 텍스트 노출이 훨씬 빠르다

#### 이미지는 어떻게 불러올 것인가?

개발자가 선택할 수 있는 이미지를 노출하는 방법에는 다음과 같은 여러 가지가 있는데

```jsx
// 1) img
<img src="lcp.jpg" />
// 2) svg
<svg xmlns="http://www.w3.org/1000/svg">
  <image href="lcp.jpg"/>
</svg>
// 3) (비디오의 경우) video.poster
<video poster="lcp.jpg"></video>
// 4) background-image: url()
<div style="background-image: url(lcp.jpg)">...</div>
```

- 1번과 3번 예제 코드가 더 빠르게 완성되는 것을 확인할 수 있다
- `<img>`
  - 이미지는 **브라우저의 프리로드 스캐너**에 의해 먼저 발견되어 빠르게 요청
  - 프리로드 스캐너: HTML을 파싱하는 단계에서 차단하지 않고 이미지와 같이 빠르게 미리 로딩하면 좋은 리소스를 찾아 로딩하는 브라우저의 기능
  - 내부의 리소스는 이처럼 **프리로드 스캐너가 병렬적으로 리소스를 다운로드**하므로 LCP 요소를 불러오기에 적절한 방법
  - `<picture>`도 마찬가지
  - **즉, 자바스크립트 리소스의 다운로드가 완료되지 않았음에도 프리로드 스캐너 덕분에 미리 발견되어 병렬 다운로드**
- `<svg>`내부의 `<img>`
  - 모든 리소스를 다 불러운 이후에 이미지를 불러온다
  - 즉, 자바스크립트 리소스가 다운로그가 완료된 후에야 이미지를 다운로드
  - 프리로드 스캐너에 의해 발견 X
  - LCP 점수에도 악영향
- `<video>`의 poster
  - poster는 사용자가 video 요소를 재생하거나 탐색하기 전까지 노출되는 요소
  - 프리로드 스캐너에 의해 조기 발견
  - poster가 없는 video의 경우, video를 실제로 로딩해 첫 번째 프레임을 해당 poster 리소스로 대체할 예정
  - 따라서, **video가 LCP에 영향을 맏을 것 같다면 poster를 반드시 넣어주는 것**이 좋다.
- background-image
  - css에 있는 리소스는 항상 느리다
  - 리소스는 브라우저가 해당 리소스를 필요로 하는 DOM을 그릴 준비가 될 때까지 리소스 요청을 뒤로 미루기 때문

#### 그 밖에 조심해야 할 사항

- 이미지 무손실 압축
  - 웹으로 서비스할 이미지는 가능한 한 무손실 형식으로 **압축해 최소한의 용량으로 서비스**하는 것이 좋다
- loading=lazy 주의
  - 리로스를 중요하지 않으믕로 표시하고 필요할 때만 로드하는 전략
  - **LCP의 이미지는 중요하지 않은 리소스로 분류해서는 안 된다**
  - 그저 로딩 속도만 늦출 뿐 지표 점수에는 도움 X
  - 상대적으로 중요하지 않은 이미지에서는 사용해도 좋지만, LCP 이미지에는 사용하지 않는 것이 좋다
- fadein과 같은 각종 애니메이션
  - 당연하게도 이미지가 그냥 뜨는 것보다 fadeIn ease 10s와 같이 처리한다면 LCP도 그만큼 늦어진다
- 클라이언트에서 빌드하지 말 것
  - 서버에서 빌드해온 HTML을 프리로드 스캐너가 바로 읽어서 LCP로 빠르게 가져가는 것이 최적의 시나리오
  - 만약 다음과 가틍ㄴ 코드가 있다면?
    ```tsx
    useEffect(() => {
      (async () => {
        const result = await fetch('https://example.com/data');
        if (result.ok) {
          setShow(true); // LCP 영역을 노출함
        }
      })();
    }, []);
    ```
    - 위와 같이 된다면, HTML을 **다운로드한 직후가 아닌 리액트 코드를 파싱하고 읽어서 API 요청을 보내고, 응답을 받은 만큼 늦어지게 된다**

## 12.4 최초 입력 지연(FID)

### 12.4.1 정의

- 순간적으로 몰린 엄청난 트래픽 때문에 웹사이트가 클릭이나 타이핑도 되지 않은 경험이 있을 것이다.
- 제아무리 페이지가 빨리 로딩된다 하더라도 사용자가 클릭을 비롯한 상호작용을 할 수 없다면, 느리다고 생각할 것 → 부정적 경험
- 웹페이지의 로딩 속도만큼 중요한 것이 **웹사이트의 반응 속도**

```
💡 웹사이트의 반응성을 측정하는 지표

   사용자가 페이지와 처음 상호 작용을 할 때부터 해당 상호 작용에 대한 응답으로
   브라우저가 실제로 이벤트 핸들러 처리를 시작하기까의 시간을 측정
```

### 12.4.2 의미

-
