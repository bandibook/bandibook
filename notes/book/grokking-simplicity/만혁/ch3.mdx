# 액션과 계산, 데이터의 차이를 알기


### 액션

- 실행 시점과 횟수에 의존
- 부수 효과가 있는 함수
- 순수하지 않은 함수
- 예/ 이메일 보내기, 데이터베이스 읽기

### 계산
- 입력으로 출력을 계산
- 순수 함수
- 수학 함수
- 예/ 최댓값 찾기, 이메일 주소가 올바른지 확인


### 데이터
- 이벤트에 대한 사실
- 예/ 사용자가 입력한 이메일 주소


### 액션과 계산, 데이터는 어디에나 적용할 수 있다.
 
일반적인 장보기 과정을 그린다면 아래와 같다.  


1. 냉장고 확인하기 -> 액션
2. 운전해서 상점으로 가기 -> 액션
3. 필요한 것 구입하기 -> 액션
4. 운전해서 집으로 오기 -> 액션


크게 보면 모든 단계들이 액션으로 구성되어있다.  

하지만 작게보면 더 나눠볼 수 있다.

#### 냉장고 확인하기 
냉장고를 확인하는 일은 시점이 중요하기에 액션이다.  
하지만 냉장고의 제품은 데이터다.


#### 운전해서 상점으로 가기
행위 자체는 명확히 액션이지만 상점 위치나 가는 경로는 데이터다.

#### 필요한 것 구입하기
구입하는 행위도 액션이지만 구입도 단계를 나눌 수 있다.

1. 현재 재고 -> 데이터
2. 필요한 재고 -> 데이터
3. 재고 빼기 -> 계산
4. 장보기 목록 -> 데이터
5. 목록에 있는 것 구입하기 -> 액션


위와 같이 반복하면 액션과 계산, 데이터를 더 많이 찾을 수 있고 풍부한 모델을 만들 수 있게된다.  

계속 나누다 보면 더 복잡해진다고 생각할 수 있지만 액션에 숨어있는 계산 또는 데이터를 발견하기 위해  
나눌 수 있는만큼 나누는게 좋다.  


### 위 과정에서 배운 것
1. 액션과 계산, 데이터는 어디에나 적용 가능하다.
2. 액션 안에는 계산과 데이터, 또 다른 액션이 숨어 있을 수 있다.
3. 계산은 더 작은 계산과 데이터로 나누고 연결한다.
4. 데이터는 데이터만 조합할 수 있다.
5. 계산은 때로 머리속에서 일어난다. -> 계산이 잘 안보이는 이유는 우리 사고 과정에 녹아있기 때문



### 새로 만드는 코드에 함수형 사고 적용하기


<details>
 <summary>연습 문제</summary>


### 추천 정책
10명 이상 추천한 사용자는 더 좋은 쿠폰을 받을 수 있다.

- 이메일 보내기 -> A
- 데이터베이스에서 구독자 가져오기 -> A
- 쿠폰에 등급 매기기 -> D
- 10명 이상 추천했는지 카운트 확인하기 -> C
- 쿠폰의 종류 확인하기 -> A
- 이메일 주소 -> D
- 추천 카운트 -> D
</details>


### 쿠폰 보내는 과정을 그려보기

1. 디비에서 구독자를 가져오기
구독자는 계속 변경되기 때문에 실행 시점에 의존하므로 액션이다.  
가져온 구독자 목록은 데이터다.  


2. 디비에서 쿠폰 목록 가져오기
쿠폰 목록 가져오기도 액션이며, 가져온 쿠폰 목록은 데이터다.

3. 보내야할 이메일 목록 만들기
구독자 목록(1)과 쿠폰 목록(2)을 기반으로 보내야할 이메일 목록을 만든다 -> 계산

4. 이메일 전송하기
전!!!!!!!!!!!송!!!!!!!!!!! -> 액션



#### 3번 자세히 보기

이메일을 보내기 전에 이메일 목록 전체를 미리 만드는게 이상할 수 있다.  
하지만 자연스러운 방법.  

이메일 목록을 계획하는 계산은 테스트하기 좋음  

액션에서 계산을 뺄 수 있다면 빼라!!  

### 쿠폰 보내는 과정 구현하기


특정 등급의 쿠폰 목록을 선택하는 것은 계산이다.

```js
 function selectCouponsByRank(coupons, rank) { // 입력
    const result = []; // 빈 배열 초기화
    for (const c = 0; c < coupons.length; c++) { // 모든 쿠폰에 반복
        const coupon = coupons[c];
        // 조건에 맞는다면 쿠폰을 배열에 넣는다.
        if (coupon.rank === rank) result.push(coupon.code);
    }
    // 출력
    return result;
 }
```


### 이미 있는 코드에 함수형 사고 적용하기

### 액션은 코드 전체로 퍼진다.


```js
function figurePayout(affiliate) {
    const owed = affiliate.sales * affiliate.commission;
    if (owed > 100) {
        sendPayout(affiliate.bankCode, owed); // 함수 내부에서 사용되는 액션
    }
}
// 함수 내부에서 액션을 호출하고 있기 때문에 전체가 액션이 된다.

function affiliatePayout(affiliates) {
    for (const a = 0; a < affiliates.length; a++) {
        figurePayout(affiliates[a]);
    }
}

// figurePayout 함수는 액션이고 이 함수를 호출하는 affiliatePayout 함수도 액션이 된다.

function main() {
    affiliatePayout(affiliates)
}

// 따라서  main  함수도 액션이 된다
```


액션을 쓰는 순간 코드 전체로 퍼져 나가기 때문에 조심해야 한다!  


### 액션은 다양한 형태로 나타난다

- 함수 호출
    - `alert('Hello World!')`
- 메서드 호출
    - `console.log('hello')`
- 생성자 -> 부르는 시점에 현재 날짜와 시간을 초기화 하기 때문에 호출되는 시점에 따라 다른 값을 지님.
    - `new Date()`
- 표현식 -> 해당 값이 공유되고 변경 가능하다면 읽는 시점에 따라 값이 다를 수 있다
    - 변수 참조 `y` 
    - 속성 참조 `user.name`
    - 배열 참조 `stack[0]`
- 상태
    - 값 할당  `z = 3;` -> 공유하기 위해 값을 할당했고 변경 가능하다면 다른 코드에 영향을 주기 때문에 액션이다
    - 속성 삭제 `delete user.name` -> 속성을 지워 다른 코드에 영향을 주기 때문에 액션이다.

    

### 1회독 후기
- 드물지만 타이밍이 어긋나는 경우는 실제로 일어난다.
- 타임라인을 나누어 생각해보면 도움 될거 같다.
- 액션을 잘게 나누는게 좋아보인다.
