# ch06. 슈퍼타입과 서브타입

## 6.1 슈퍼타입 & 서브타입 정의
- 슈퍼타입(supertypes): 데이터를 일반화, 상위 집합
- 서브타입(subtypes): 슈퍼타입의 부분집합, 특수화된 개념

**왜 사용하는가?**
- 엔티티가 복잡하면 여러 서브타입을 나눠 단순한 모델로 관리
- 중복 속성이 존재하면 슈퍼타입을 도출해서 제거
  - 중복 속성은 슈퍼타입에서, 고유한 개별 속성은 서브타입에서 관리

**서브타입 엔티티 간의 관계**
- 상호 배타적(Exclusive) - 일반적
  - 서브타입 집합을 모두 합하면 슈퍼타입의 집합
  - 서브타입 인스턴스는 반드시 그에 해당하는 슈퍼타입 인스턴스가 존재해야 함
  - But 슈퍼타입에 해당하는 서브타입이 없을 수 있음 
- 포함적(Inclusive)

cf. 
- 슈퍼타입과 서브타입은 부모-자식 관계가 아님
- `슈퍼타입 인스턴스 + 서브타입 인스턴스 => 하나의 완전한 인스턴스` 개념

**복잡한 배타 관계는 지양하자**
- 한 엔티티가 두 개의 엔티티와 배타 관계를 가지는 것은 바람직한 것이 아님 (복잡한 모델이니까)
- => 이런 엔티티는 통합(일반화)해 슈퍼타입을 도출해야 함

**고객을 통합해서 관리하는 엔티티**
- 구분자(Subtype Discriminator)로 서브타입을 구분할 순 있지만,
- 어떤 속성이 각 구분에 따라 nullable한 지 파악 불가
- 또한 각 서브타입이 다른 엔티티와 어떤 관계가 있는지 직관적인 파악 불가

=> 업무 규칙이 반영이 안 돼 있어 바람직한 논리 모델이 아님!

**효율적인 물리 구조를 결정하기 위한 슈퍼타입, 서브타입**
- 서브타입을 통해 모델의 확장성 고려 가능
- 슈퍼타입으로 공통점을, 서브타입으로 차이점을 파악하기 유용
- **업무 규칙을 모델에 표현하기 쉬움**
  - 슈퍼타입의 공통 속성과 관계, 서브타입별 고유 속성과 관계가 표현

---

## 6.2 슈퍼타입과 서브타입의 사용 방법
**엔티티명 정의**
- 집합의 성격이 고정적이면 : 구체적으로 정의
  - e.g. 서적
- 집합의 성격이 가변적이면 : 추후 추가(통합)될 결합 가능성을 고려해 일반화해서 정의
  - e.g. 상품

**서브타입 종류**
- 이다(is-A) 관계
  - e.g. 슈퍼타입: 사원, 서브타입: 관리자, 기술자, 비서
    - 관리자는 [ 사원이다. 기술자이다. 비서이다. ]
  - 즉, 서브타입은 슈퍼타입의 종류이면서 부분집합
  - 관리자, 기술자, 비서가 존재하면 3개의 인스턴스 존재
- 일부(Part-Of) 관계
  - e.g. 슈퍼타입: 소프트웨어, 서브타입: 프로그램, 사용자메뉴얼
  - 서브타입 둘 다 모여야 온전한 소프트웨어가 된다.
  - 서브타입 간에는 공통된 속성이 존재하지 않고 각자 고유한 속성만이 존재
  - 소프트웨어, 하나의 인스턴스 존재
- 코드성 데이터를 표현할 때
  - e.g. 슈퍼타입: 고객 상태, 서브타입: 가입, 탈퇴, 임시 상태
  - 적절하게 사용하면 모델의 가독성을 극적으로 높여줌
  - 핵심적인 코드만 표현하는 것을 권장 (논리 모델에는 개념모델보다 많은 코드 속성이 서브타입으로 표현되기 때문)
  - 전체 집합 대상보단, 특정 속성 대상으로 하여 핵심 서브타입을 두자.

---

## 6.3 서브타입의 종류
- `배타(Exclusive 또는 Disjoint) 서브타입` (일반적인 경우)
  - 서브타입 부분 집합 간에 공통부분을 갖지 않는 서브타입
  - 일반적으로 전체 서브타입의 합은 슈퍼타입
  - 서브타입 기호에 X 표시하면 배타 서브타입
  - **실제로 발생하는 대부분 서브타입의 경우**
  - 일반화를 수행해 서브타입을 도출하는 것이 관건, 후에 데이터 관리는 수월함
- `중복(Inclusive 또는 Overlapping) 서브타입`  
  - 겹쳐지는 부분이 존재하는 서브타입
  - 서브타입 기호에 X 표시가 없으면 중복 서브타입
  - 슈퍼타입의 하나의 인스턴스는 최소 하나 이상의 서브타입과 관계가 존재
  - 자주 발생하지 않는 대신 데이터를 관리하는 방법이 어려움

- `완전 서브타입` (일반적인 경우)
  - 슈퍼타입의 모든 인스턴스가 최소한 하나의 서브타입 인스턴스로 반드시 존재하는 경우
  - 슈퍼타입에 인스턴스가 생성될 때 서브타입에도 인스턴스가 생성됨
    - 한 개의 인스턴스만 생성되면 배타 서브타입
    - 하나 이상 생성되면 중복 서브타입
  - 슈퍼타입 인스턴스 삭제 시, 서브타입의 모든 인스턴스도 삭제해야 한다/ 
- `불완전 서브타입`
  - 슈퍼타입에만 인스턴스가 존재하고 서브타입에는 인스턴스가 존재하지 않는 경우
  - 슈퍼타입에 인스턴스가 생성될 때 서브타입에 인스턴스 생성 안됨

> 서브타입으로 도출된 엔티티는 핵심 엔티티일 가능성이 크므로 심도있게 고민해야 한다.

---

## 6.4 서브타입의 물리모델 변환

> 도출된 서브타입은 성능과 관리 효율성, 사용 결합도 등을 고려해 물리 모델링 단계에서 엔티티 분할 여부를 결정한다.


**변환 방법 3가지**
1. 타입 1 - `분할`
   - 서브타입 별 업무가 독립적일 때
   - 서브타입 별 속성 또는 관계가 많이 다를 때
   - 모든 서브타입을 동시에 조회하는 경우가 드물 때
   - 서브타입 별 주 식별자가 상호 배타적이 아닐 때
   - 서브타입이 업무적으로 서로 약결합(Loosely Coupled)관계일 때
2. 타입 2 - `통합`
   - 서브타입 별 고유 속성이 적을 때
   - 서브타입이 지속적으로 늘어날 가능성이 작을 때
   - 하나의 서브타입은 속성도 많고 업무도 중요하며 나머지 서브타입은 덜 중요할 때
   - 서브타입 전체 대상으로 업무가 빈번할 때
   - 데이터 건수가 많지 않을 때
   - 업무가 중요하지 않을 때
   - 서브타입이 서로 포함 관계일 때
   - 서브타입이 업무적으로 서로 강결합(Tightly Coupled)관계일 때
3. 타입 3 - `혼합`
  - 서브타입 별 공통 속성을 대상으로 하는 업무가 빈번할 때
  - 통합(타입 2)하면 속성 개수가 많아질 때
  - 업무의 변화가 빈번해 속성 개수가 너무 많아질 때
  - 서브타입 별 고유 속성이 많을 때
  - 트랜잭션의 락을 방지하기 위해 엔티티를 분리해야 할 때
  - 공통 업무와 고유 업무가 다양하게 존재할 때
  - 중요 속성과 참고 속성으로 분리할 수 있을 때
  - 슈퍼타입의 조회가 빈번하고 조회 범위가 넓을 때
  - 서브타입이 업무적으로 강 결합 관계일 때