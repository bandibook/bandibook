# ch04. 정규화 (Normalization)

## 4.1 정규화란?

- 함수 종속 개념을 기반으로 유사한 속성들은 모으고 종속성이 없는 속성들을 분리하는 것
- 더는 분해(Decomposition)될 수 없는 엔티티로 만드는 것
- 데이터를 완전히 이해하는 과정
    - 데이터의 성격에 맞는 엔티티 정의, 엔티티 간의 관계도 명확해짐
    - 결국 잘 구조화된 모델은 정규형 모델
    - 확장성 향상
- 아노말리(데이터 이상 현상)의 최소화 -> 데이터 품질 향상


- 성능 문제는 주로 조회에서 발생하므로, 업데이트 성능은 양보할 수 있지만 데이터 정합성이 깨질 수 있도록 설계하는 것은 치명적임
    - ➡️ 정규화의 가장 큰 목적은 중복 데이터를 제거하는 것

---

## 4.2 정규화의 목적

```
정규화를 수행하는 가장 큰 목표는 안정성과 확장성 제고
```

- 가장 근본적인 이유는 **중복 데이터(속성, 엔티티)를 제거**하기 위함
    - 데이터 이상 현상 방지 목적
    - RDB는 관계라는 개념이 존재해 중복을 완전히 제거하는 것은 불가. 하지만 데이터 중복을 최소화해야 한다.
- 정규화를 하면 **데이터의 성격에 맞는 엔티티가 도출**
    - 추가 업무가 발생했을 때 이미 존재하는 엔티티에 통합할지, 엔티티를 추가할지, 속성을 추가할지가 명확해짐
    - 또한 그에 따른 엔티티 간의 관계도 명확해짐
    - 반면에 정규화되지 않은 엔티티를 확장하는 것은 매우 어려움
- 데이터 저장 공간의 사용을 최소화, 데이터 모델을 단순화
    - 성능 개선, 모델 관리 수월해짐
    - 단순한 모델이 좋은 모델!

---

## 4.3 아노말리

- 데이터의 이상 현상은 중복 데이터 때문에 발생
    - 중복 데이터를 동시에 전부 처리하지 못하고 일부만 처리하면 어떤 데이터가 맞는 데이터인지 알 수 없게 된다.

**아노말리 종류**

- 업데이트 아노말리(Update Anomaly): 릴레이션에서 속성의 값을 업데이트할 때 발생하는 데이터 이상현상
- 삭제 아노말리(Deletion Anomaly): 릴레이션에서 인스턴스를 삭제할 때 발생하는 데이터 이상현상
- 삽입 아노말리(Addition Anomaly): 릴레이션에 새로운 인스턴스를 삽입할 때 발생하는 데이터 이상현상

---

## 4.4 함수종속

- 데이터 종속성의 대표적인 종속성인 함수 종속(Functional Dependency)
- 함수 종속 외에도 다가 종속(Multivalued Dependency), 조인 종속(Join Dependency) 등 존재

**함수 종속?**

- 릴레이션 내에 존재하는 속성 간의 종속성을 의미하며, 대표 속성(식별자)과 나머지 속성 사이의 연관 관계가 함수 종속이다.
- `결정자(Determinant)` : 속성 간의 종속성을 규명할 때 기준이 되는 값
- `종속자(Dependent)` : 결정자의 값에 의해 정해지는 값
- 결정자 X의 값은 반드시 하나의 Y 값과 연관된다. X는 Y를 함수적으로 결정한다.
    - x -> y
    - y = f(x)
    - X: 결정자(Determinant), Y: 종속자(Dependent)
- e.g. `X: 주민등록번호, Y: 이름 등` : 주민등록번호가 이름 등을 유일하게 결정한다.
- 역은 성립되지 않는다. 반례를 찾을 수 없다면 함수 종속이 성립함을 의미


- X -> Y와 같이 속성 간의 종속(직접 종속) 관계가 발생하면 X와 Y는 항상 함께 존재해야 한다. 이러한 함수 종속(FD)에 근거해 엔티티가 생성됨. 모든 FD의 결정자는 엔티티의 주 식별자
    - 함수 종속은 일반적으로 직접 종속을 의미
    - 함수 종속의 결정자가 키가 되도록 릴레이션을 분해하는 과정이 정규화

- X -> Y -> Z 종속이 있다면 Z는 X에 간접적으로 종속돼 있다. (이행 종속)
    - X/Y/Z 를 하나의 엔티티에 포함시키면 안 되고 직접 종속인 X와 Y를 하나의 엔티티로, 그리고 Y와 Z를 하나의 엔티티로 도출해야 한다.

### 정규형 도출 방법

1. 정규화하려는 릴레이션의 `키를 도출`하는 것이 우선, 그 뒤 2정규화, 3정규화 등 수행
    - R 릴레이션의 속성 X가 키인지를 알려면 X의 폐포(Closure)를 알아야 한다.
    - 폐포를 구하려면 R 릴레이션에 존재하는 모든 함수 종속을 알아야 한다.
        - e.g. X -> Y, Z 라면, X의 폐포는 X, Y, Z
2. 릴레이션에 존재하는 모든 함수 종속을 구하는 것. 도출된 각 함수 종속은 정규형 엔티티가 된다.

엔티티는 정규화에 의해 생성, 정규화는 함수 종속에 의해 수행, 함수 종속은 결정자 없이는 존재할 수 없는 개념 <br>
‼️ 최종적으로 도출할 엔티티와 주 식별자는 하나라 봐도 무방

---

## 4.5 정규형의 종류

- 1정규형, 2정규형, 3정규형이 정규화 대상의 대부분을 차지하지만, 중요한 것은 BC 정규형, 4정규형, 5정규형임.
- 전자는 직관적으로 알 수 있는 정규형이지만, 후자 케이스룰 위배해서 발생한 데이터 이상 현상은 단순하지 않으며 발견하지 못할 수도 있기 때문이다.

정규화를 수행할 때 사례와 반례를 적절하게 활용하자 <br>

- e.g. 릴레이션에 데이터를 생성시켜 정규화를 위반하는지를 검토

### 1정규형

```
- 다가 속성, 복합 속성, 반복 속성, 중첩 릴레이션 제거 : 속성이 추가되거나 일대다(1:M) 관계의 릴레이션이 추가되며 관계를 상속시킴
```

- 다가 속성 : 같은 종류의 값을 여러 개 가지는 속성을 의미
    - e.g. 전화번호 컬럼에 123-4567, 234-5678, 345-6789와 같이 여러 값이 들어가는 경우
    - 전화번호는 식별자에 함수적으로 종속되지 않음. 유일하게 식별할 수 있는 전화번호가 없다.
    - 릴레이션의 모든 속성은 단일 값을 가져야 하므로, 다가 속성이 존재하면 새로운 릴레이션이 필요함. (`릴레이션 분리`)
    - 하지만 때에 따라 쿼리(조회) 성능을 고려해야 함. 최대로 관리할 전화번호가 고정적이라면 집전화번호, 사무실전화번호, 휴대전화번호 세 개의 필드로 관리하는 것이 효율적일 수 있음
- 복합 속성 : 하나의 속성이 여러 개의 속성으로 분리될 수 있을 때
    - e.g. 주소 (시/구/동/번지), 날짜 (년/월/일)
    - 복합 속성처럼 보인다고 무조건 분해하면 안되고, 대부분 요건(Information Requirement)에 따라 결정해야 함
    - 항상 한꺼번에 입력하고 한꺼번에 조회하는데 분해해서 입력하고 합쳐서 조회하는 것은 바람직하지 않음

c.f.
상위 수준의 개념 모델링 단계에서는 관련된 정규화를 완전하게 수행하지 않을 수 있다.
이는 비정규형인 채로 둔다는 것을 의미하지 않으며, 비정규화를 한다는 것도 아니다.

### 2정규형

> 부분 종속 제거 : 일대다(1:M) 관계의 릴레이션이 추가되며 관계를 상속받음

- 후보 식별자를 구성하는 속성이 두 개 이상일 때만 대상이 되고, 단일 속성으로 후보 식별자가 구성되면 대상이 아님
- 두 개 이상의 속성이 후보 식별자로 구성된 경우 일반 속성 중에서 후보 식별자 전체에 종속적이지 않은 속성을 찾아 기본 엔티티에서 제거하고, 그 속성의 결정자를 주 식별자로 하는 새로운 상위 엔티티를 생성하는
  것이 2정규화
- 주 식별자 전체에 종속되지 않고 부분 함수 종속되는 경우는 2정규형에 어긋나므로, 해당 엔티티에서 제외하고, 별도 엔티티로 분리한다.
- 엔티티 분리 과정에서 조인을 피하려 중복 속성을 사용하는 것도 지양해야 한다.
- 더 중요한 것은 정규형을 만들려고 엔티티를 생성하는 것보다 기존에 사용되고 있는 엔티티가 있는지를 검토하고, 만약 엔티티와 해당 속성이 존재하면 중복된 속성은 삭제해야 함

### 3정규형

> 이행 종속 제거 : 일대다(1:M) 관계의 릴레이션이 추가되며 관계를 상속받음

- 이행적 종속성(Transitive Dependency)을 제거해야 함
- X -> Y 이고, Y -> Z 이면 X -> Z가 성립.
    - 속성 Y : 일반 속성이면서, 속성 D의 결정자.
    - 속성 D : 종속 D는 종속자이면서 주 식별자의 이행 종속 속성
    - => #Y, Z 를 분해해서 새로운 릴레이션으로 생성

c.f.
- 정규화의 대상을 논할 때 흔히 3정규화까지 수행하면 충분하다는 의견이 많음
- But BC 정규형과 4정규형을 만족해야 데이터가 제대로 관리될 수 있는 요건이 있으므로 중요함.

### 보이스코드 정규형 (Boyce-Codd Normal Form)

> 종속자가 키에 포함된 함수 종속 제거 : 모든 결정자는 키이어야 한다는 관점에서 3정규형과 동일

- 3정규형을 보강한 정규형으로, 3정규형보다 드물게 발생하지만 실무에 적용하기 이상적이라 언급되는 정규형 중 하나
- BC 정규형이란 모든 결정자는 주 식별자이어야 한다. 3정규형과 구분하면, 릴레이션에 존재하는 종속자가 후보 식별자면 BC정규형이 아님
- 식별자이지만 종속자인 속성은 원본 릴레이션에서 분리돼 새로운 릴레이션의 종속자가 되도록 정규화

- 엔티티가 많이 발생하는 우려하거나 관리할 속성이 많지 않아 특정 엔티티에서 같이 관리할 수도 있다.
- 하지만 엔티티가 실체 성격의 데이터이면 관리 속성이나 데이터가 적더라도 별도의 엔티티로 분리해 관리하는 것이 바람직함

### 4정규형

> 다가 종속 제거 : 다가 속성의 개수만큼 일대다(1:M) 관계의 릴레이션이 추가됨

- `다가 종속 개념(MVD: Multivalued Dependency)` 기반의 정규형
    - c.f. 2정규형, 3정규형, BC정규형: 함수 종속 개념 기반
- 다가 종속은 하나의 A 값에 대응하는 여러 개의 B 값이 있고, A 값에 대응하는 여러 개의 C 값이 있다. 이때 B값과 C 값 사이는 아무런 상관 관계가 없는데 A/B/C 값을 하나의 릴레이션에서 관리할 때
  발생
- 즉, 두 개의 독립적인 일대다(1:M) 관계의 속성이 동일한 릴레이션에 존재하면 다가 종속 발생
- 속성 A의 하나의 값이 속성 B의 여러 값을 결정하면 'A->->B'로 표시, 'A가 B를 다가 결정한다' 또는 'B가 A에 다가 종속됐다' 라고 표현
- 하지만 B와 C는 독립적인 속성으로, A/B/C를 주 식별자로 하는 릴레이션으로 변경한다면?
    - 두 개의 독립된 일대다 관계를 하나의 엔티티에 관리하면 다가 종속이 발생
    - N*M만큼의 인스턴스 생성, 중복 데이터 발생함 (A와 B가 1:N, A와 C가 1:M이라 할 때)
- 4정규화는 다가 종속이 발생한 릴레이션에서 새로운 엔티티를 생성해 다가 종속을 제거하는 것 (두 개의 릴레이션 분리)
    - 업데이트, 삽입, 삭제 아노말리 최소화 및 데이터 사용 공간 절약
- 4정규형은 자연히 BC정규형으로, 다가 종속이 발생한 속성들은 대게 주 식별자가 된다.
- 이때 다가 속성 간 연관관계가 있다면 엔티티를 분해하면 안됨. 분해하면 연관 관계 사라져서 요건을 만족하지 못하게 됨

### 5정규형

> 조인 종속 제거 : 조인 종속이 존재하는 릴레이션이 사용하기 편함. 지나치게 이상적인 정규형

- 조인 종속이 없는 모델
- 필요한 데이터가 사라지지 않는 무손실 분해가 되고 필요 없는 데이터가 생기지 않는 비부가적 분해가 된 릴레이션
- 4정규형과 유사하지만 다른 점은 B와 C는 관계가 있으므로 세 속성 사이에는 연관성이 존재
- 릴레이션을 분할하고(Project) 합치는(Join) 개념 때문에 PJ정규형(Project-Join Normal Form)이라고도 함
- 5정규형이 만족하도록 설계하면 오히려 엔티티가 늘어나며 중복 성격의 데이터가 생기고, 사용하려면 어차피 조인해야 해서 실제로 적용하는 예는 드물다.
- 5정규형을 알아야하는 이유는 실무에서 오히려 효율적이지 않아서 사용하지 않기 위해서라도 구분할 수 있어야 한다.

---

## 4.6 정규형과 성능

최소한의 블록을 사용해야 한다는 궁극적인 목표가 있는 조회 성능은, 동일한 데이터를 한 블록에 최대한 많이 가질 수 있도록 하는 정규형으로 말미암아 목표를 달성할 수 있다.
- 오라클은 데이터를 블록 단위로 읽는다. (대부분 DBMS도 비슷) 
- 해당 데이터가 메모리에 이미 존재하면 바로 메모리에서 빠르게 읽을 수 있다. 
- 정규화를 하면 중복 데이터가 최소화되고 인스턴스 크기가 작아진다. 
- 한 블록에 많은 인스턴스가 존재하면 한 번 메모리에 올라온 블록이 다시 사용될 가능성이 커진다. (적중률 Hit Ratio 높아짐)

모델링을 수행하면서 모든 조회 요건을 고려하는 것은 불가능함. (무결성, 화면 구성 등)
- 해당 엔티티의 조회 요건이 주로 목록인지 명세(상세)인지 확인하고, 목록 위주면 조회 성능을 고려하고 상세면 무결성을 고려한다.
- 성능 이슈는 개념/논리/물리 모델링 각 단계에서 가능한 빠른 단계에서 검토하는 것이 바람직하며,
- 검토는 정규화를 한 상태에서 진행돼야 한다.