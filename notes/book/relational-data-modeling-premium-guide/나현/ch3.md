# ch03. 개념모델 & 논리모델 & 물리모델

## 3.1 개념 모델(Conceptual Model)

> **목적:** 업무에서 핵심적으로 사용되는 데이터의 **견고한 토대**를 세우는 것

### 주요 요소
- **핵심 엔티티**
- **엔티티 간 관계**

### 특징
- 고려 대상을 줄여 분석 단순화
- 빠른 이해·의사소통 지원
- 상위 수준 모델이라도 반드시 **모형**으로 존재해야 함

### 고려사항
- **핵심 엔티티 정의 + 관계 규명**이 가장 중요  
  → 엔티티 정의가 달라지면 속성과 관계가 모두 변함  
  → 작은 정의 오류도 전체 시스템에 큰 영향
- 개념 모델은 논리 모델과 **연결(Alignment)** 되어야 함  
  → 구조와 정의가 일관되게 유지되어야 함


### 개념 모델링 주요 Task

#### 1. 요구 분석
- 데이터 관점의 요구사항 분석과 모델링을 **동시에** 진행
- 현행 데이터를 잘 아는 담당자와 **최대한 많은 인터뷰**
- 현행 문제점·개선점 파악

#### 2. 중요 엔티티 선별
- 너무 상세하게 도출하지 말 것
- 논리 모델링의 **30% 정도의 기간**에 수행

#### 3. 엔티티 정의
- 데이터 구성 요소, 속성, 결정자 속성 규명
- 데이터 성격(정체성)에 맞게 정의

#### 4. 식별자 정의
- 식별자와 엔티티는 불가분 관계
- **식별자 + 2~3개의 핵심 속성**만 표현 (가독성 유지)

#### 5. 엔티티 통합
- 유사 데이터는 일반화(Generalization)  
  → 주제 영역 잘못 설정 시 중복 엔티티 발생
- **모델 오너십**: 주제 영역이 서로 다른 엔티티를 통합할 때는 통합된 엔티티가 속하게 되는 주제 영역이 어디인지를 결정 필요

#### 6. 엔티티 간 관계 도출
- 핵심 엔티티 간 관계는 **불변**이어야 함
- **참조 무결성 제약**과 직결 → 반드시 실제 존재하는 관계만 표현

---

## 3.2 논리 모델(Logical Model)
> **목적:** 비즈니스 요건을 빠짐없이 정확히 반영 → 모델링의 **완성 단계**

### 개념 모델 vs 논리 모델
- 개념 모델: **방향성** 제시, 핵심 엔티티·관계 중심
- 논리 모델: 모든 엔티티·속성·관계 도출 → 물리 모델과 거의 동일 구조
- 논리 모델이 완료되면 구조적으로 대부분 결정됨

### 주요 단계

#### 1. 엔티티 정의
- 구축된 핵심 엔티티 중심으로 전체 엔티티 상세화
- 데이터의 정체성 유지, 중복/혼재 데이터 방지
- 주 식별자도 같이 정의

#### 2. 관계 도출
- 엔티티 간 모든 관계 정의
- 참조 무결성 제약 없는 관계는 표현하지 않음

#### 3. 속성 도출
- 모든 속성 포함 (시스템 속성 제외)
- 성능 고려는 제한적, 중복 속성은 최소화
    - 성능 문제는 개발에 종속적이기 때문

> 개발 단계에서 물리 모델의 구조 변경 방지를 위해 논리 모델에 중복, 추출 속성을 무분별하게 반영해 놓는 것은 심각한 상황

#### 4. 주 식별자 확정
- 주변 관계까지 고려하여 최종 확정
- 물리 모델 단계에서 PK 변경은 최소화

#### 5. 정규화
- 완전한 정규형 모델을 지향  
  → 성능 문제 발견 시 **비정규화** 검토

#### 6. 이력 관리
- **내역 데이터** vs **이력 데이터** 구분
    - 내역 데이터는 데이터가 새로 생기는 경우
    - 이력 데이터는 이미 생성된 데이터가 변경되는 경우
- 핵심 엔티티는 이력 관리 방법까지 함께 설계
    - why? 이력 관리 방법에 따라 주 식별자가 달라질 수 있고 이로 인해 다른 엔티티 관계가 변경될 수 있음

#### 7. 논리 모델 검증
- 현행 엔티티/속성, 애플리케이션(향후 화면), 사례 데이터와 **매핑**
- 검증보다 **정확한 엔티티 정의**가 우선

---

## 3.3 물리 모델(Physical Model)
> **목적:** 성능 최적화를 위한 **실행 가능한 데이터베이스 설계**

### 특징
- 논리 모델이 구조를 결정 → 물리 모델은 **물리적 요소** 설계
- 구조 변화는 10% 이내여야 함

### 주요 고려사항
1. **모델 차원(ERD)**
    - 성능 고려한 비정규화
    - 집계·백업·복제 엔티티 추가 가능
    - 서브타입 통합/분리 결정은 가능하면 일찍
    - 시스템 속성은 DB 생성 직전에 추가
2. **물리적 요소(DBMS)**
    - 인덱스, 파티션, 클러스터, 뷰 등
    - 실제 데이터·SQL 기반으로 설계
    - 데이터의 액세스 경로를 화면만으로 판단하는 것엔 무리가 있고, 실데이터가 존재해야 실행계획을 참조할 수 있어 모델이 데이터베이스 구현된 이후에 인덱스를 설계하는 것이 올바른 순서이다.
---

### 물리 모델링 주요 Task

#### 1. 서브타입 모델 변환
- 통합/분리 결정은 빠를수록 좋음

#### 2. 엔티티 합체·분해
- 주로 성능 문제 해결 목적  
  (일대일 관계와 연관, 비정규화와 구분)

#### 3. 비정규화
- 성능 문제 해결 목적 외에는 지양
- 정규화 후 필요 시 비정규화

#### 4. PK 확정
- 논리 모델의 주 식별자를 기반으로 최종 확정  
  (성능, 파티션, 비정규화 고려, 인덱스 효율성 등 고려한 약간의 조정)

#### 5. 테이블 파티션 확정
- 성능 + 관리 + 가용성 측면 고려
- 백업 정책, 파티션 키에 따라 속성 변경 가능성 영향
- 파티션 대상이 되는 후보 엔티티는 이미 핵심 엔티티, 단계 상관없이 지속적 관심 필요

#### 6. 데이터 저장 방법 확정
- 기본: 입력 순서 저장
- 필요 시 특정 속성 기준 클러스터링

#### 7. 인덱스 설계
- 주·외래·후보 식별자가 1차 후보
- 실제 데이터·SQL 분석 후 최종 확정

#### 8. 뷰 설계
- 조인 최소화, 중복 속성 감소, 무결성 향상

#### 9. 시스템 속성 추가
- 최소화, 업무와 분리
- 논의는 빠르게, 적용은 DB 생성 직전에

