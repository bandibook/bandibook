# 섹션 0. 강의 소개

### 김영한

- 카카오, SK 플래닛, 우아한형제들 개발 팀장
- 저서: 자바 ORM 표준 JPA 프로그래밍

### 스프링 핵심 원리

객체지향과 스프링을 함께 이해해야 함.

스프링이 제공하는 핵심 가치와 원리를 이해하고 개발해야 함.

- IoC
- DI
- 컨테이너
- SOLID
- SRP
- OCP / DIP
- 다형성

### 스프링의 핵심 가치

객체 지향 프로그래밍

스프링이 왜 만들어졌는지부터 이해하고 스프링이 문제를 어떻게 해결해 나갔는지 배우는 강의

### 강의 목차

1. 객체 지향 설계와 스프링
2. 스프링 핵심 원리 이해 1 - 예제 만들기
3. 스프링 핵심 원리 이해 2 - 객체 지향 원리 적용
4. 스프링 컨테이너와 스프링 빈
5. 싱글톤 컨테이너
6. 컴포넌트 스캔
7. 의존관계 자동 주입
8. 빈 생명주기 콜백
9. 빈 스코프

### 강의 목표

- 스프링 기본 기능 학습
- 스프링 본질 깊은 이해
- 객체 지향 설계를 고민하는 개발자로 성장

스프링 핵심 원리 - 중급편

- 기본편
    - 객체 지향 설계와 스프링의 핵심 원리
    - 스프링을 사용할 때 필수로 알아야 하는 핵심 기능
- 중급편
    - 기본편에서 다루지 않은 컨테이너 확장 포인트, AOP 동작 원리, 기타 기능들
    - 스프링의 난이도 있는 내용들을 주로 다루는 심화과정

---

# 섹션 1. 객체 지향 설계와 스프링

### 자바 진영의 추운 겨울과 스프링의 탄생

- 2000년 초반 EJB (Enterprise Java Beans)
    - 자바 진영의 표준 기술
    - Spring과 JPA를 다 합쳐놓은 종합 세트
    - 기술 영업을 할 때 EJB를 가지고 많이 함
    - 설정에 의한 transaction, 분산 네트워크 기술 등 검증된 다양한 기능 사용 가능
    - 하지만 비싸고, 어렵고, 복잡하고, 느린 문제가 있었음
    - 따라서 EJB 의존적으로 짜면서 복잡해지는 문제를 해결하기 위해, 순수한 자바로 돌아가자라는 관점에서 POJO(Plain Old Java Object)를 사용하는 진영도 생김.
- Spring Framework 오픈 소스 개발
    - EJB 컨테이너 대체
    - 단순함의 승리
    - 현재 사실상 표준 기술
- Hibernate 오픈 소스 개발
    - EJB Entity Bean 기술 대체
    - JPA (Java Persistence API) 새로운 표준 정의
        - Hibernate가 너무 널리 사용되어 EJB Entity Bean → Hibernate를 표준으로 JPA를 정의함
        - 그래서 JPA는 표준 인터페이스이고, 구현체가 Hibernate가 된 것.
        - 표준 기술은 interface만 있고 구현체는 따로 만들어야 함.
        - 실용과 안정성이 잘 합쳐져서 성공적으로 JPA가 정의된 케이스

### 스프링 역사

- 2002 로드 존슨(Rod Johnson) 책 출간
- EJB의 문제점 지적
- EJB 없이도 충분히 고품질의 확장 가능한 애플리케이션을 개발할 수 있음을 보여주고, 30,000 라인 이상의 기반 기술을 예제 코드로 선보임
- 여기에 지금의 스프링 핵심 개념과 기반 코드가 들어가 있음
- BeanFactory, ApplicationContext, POJO, 제어의 역전, 의존관계 주입
- 책 출간 후 유겐 휠러(Juergen Hoeller), 얀 카로프(Yann Caroff)가 로드 존슨에게 오픈소스 프로젝트를 제안
- 스피링의 핵심 코드의 상당수는 유겐 휠러가 지금도 개발 중
- `스프링`이란 이름은 전통적인 J2EE(EJB)라는 경울을 넘어 새로운 시작이라는 뜻으로 지음

### 스프링 릴리즈

- 2003년 스프링 프레임워크 1.0 출시 - XML
- 2006년 스프링 프레임워크 2.0 출시 - XML 편의 기능 지원
- 2009년 스프링 프레임워크 3.0 출시 - 자바 코드로 설정
- 2013년 스프링 프레임워크 4.0 출시 - 자바 8
- 2014년 스프링 부트 1.0 출시
    - 스프링이 다 좋은데 설정이 너무 어려운 문제가 있었음. (스프링은 설정이 절반이다..)
    - 예를 들어, 웹 앱을 만들 때 톰켓 웹 서버 설정을 하는 과정이 복잡함.
    - 서버를 포함시키고, 기본 값을 설정해둠으로써 간단하게 개발 가능해짐.
- 2017년 스프링 프레임워크 5.0, 스프링 부트 2.0 출시 - 리엑티브 프로그래밍 지원
- 2022년 스프링 프레임워크 6, 스프링 부트 3.0 출시

## 스프링이란?

### 스프링 생태계

- 필수
    - 스프링 프레임워크
    - 스프링 부트
- 선택
    - 스프링 데이터 (Spring Data JPA)
        - 데이터베이스(RDB, NoSQL)의 기본적인 CRUD를 편리하게 사용할 수 있는 기능 제공
    - 스프링 세션
        - Session 기능을 편리하게 사용할 수 있도록 도움
    - 스프링 시큐리티
    - 스프링 Rest Docs
    - 스프링 배치
        - 1000만명의 데이터를 한번에 업데이트한다 ← 이런 것은 실시간으로 하기 어려움.  따라서, 100건씩, 1000건씩 퍼올려서 작업하는 과정을 배치 처리라고 하고, 이 배치 처리에 특화된 기술.
    - 스프링 클라우드
    - … [spring.io](http://spring.io) 페이지에서 확인

### 스프링 프레임워크

- 핵심 기술: 스프링 DI 컨테이너, AOP, 이벤트, 기타 등등
- 웹 기술: 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술: 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합: 캐시, 이메일, 원격접근, 스케줄링
- 테스트: 스프링 기반 테스트 지원
- 언어: 코틀린, 그루비
- 최근에는 스프링 부트를 통해서 스프링 프레임워크의 기술들을 편리하게 사용

### 스프링 부트

- 스프링을 편리하게 사용할 수 있도록 지원, 최근에는 기본으로 사용
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성
- Tomcat 같은 웹 서버를 내장해서 별도의 웹 서버를 설치하지 않아도 됨
- 손쉬운 빌드 구성을 위한 starter 종속성 제공
    - 스프링 프레임워크를 사용하려면 여러 라이브러리를 연동해야 함.
    - Spring boot는 xxx-starter을 사용하면 관련된 여러 라이브러리의 묶음을 제공함. (예: spring-data-jpa-starter 등)
- 스프링과 3rd party(외부) 라이브러리 자동 구성
    - 스프링 프레임워크의 버전에 따라 외부 라이브러리 버전이 맞지 않는 부분이 있음.
    - 스프링 부트는 스프링 프레임워크 버전에 맞게 외부 라이브러리의 버전을 확인해줌 (메이저 라이브러리는 스프링 부트가 스프링 프레임워크와의 궁합이 잘 맞는지 다 테스트를 하면서 적합한 버전 제공)
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공
    - 운영 환경에서 모니터링할 수 있도록 스프링 부트가 기본적인 기능을 제공함.
- 관례에 의한 간결한 설정
- 스프링 부트는 Spring Framework와 별도로 사용할 수 있는 게 아님.
    - 스프링 부트는 여러 스프링 프레임워크를 중간에서 편리하게 사용할 수 있는 기능들을 제공하는 것.

### 스프링 단어?

스프링이라는 단어는 문맥에 따라 다르게 사용된다.

- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 스프링 생태계

## 스프링 왜 만들었나?

### 핵심 개념

> 아무리 복잡한 기술도 핵심 컨셉은 항상 단순하다.
> 
- 이 기술을 왜 만들었는가?
- 이 기술의 핵심 컨셉은?

### 스프링의 핵심 개념, 컨셉?

- 웹 애플리케이션 만들고, DB 접근 편리하게 해주는 기술?
- 전자정부 프레임워크?
- 웹 서버도 자동으로 띄워주고?
- 클라우드, 마이크로서비스?

### 스프링의 진짜 핵심

- 스프링은 자바 언어 기반의 프레임워크
- 자바 언어의 가장 큰 특징 - 객체 지향 언어
- 스프링은 객체 지향 언어가 가진 강력한 특징을 살려내는 프레임워크
- **스프링은 좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크**

## 좋은 객체 지향 프로그래밍

### 객체 지향 특징

> 객체 지향 프로그래밍은 컴퓨터 프로그램을 명령어의 목록으로 보는 시각에서 벗어나 여러개의 독립된 단위, 즉 `“객체”`들의 `모임`으로 파악하고자 하는 것이다. 각각의 객체는 `메시지`를 주고받고, 데이터를 처리할 수 있다. (`협력`)
객체 지향 프로그래밍은 프로그램을 `유연`하고 `변경`이 용이하게 만들기 때문에 대규모 소프트웨어 개발에 많이 사용된다.
> 
- 추상화
- 캡슐화
- 상속
- 다형성

### 유연하고, 변경이 용이?

- 레고 블럭 조립하듯이
- 키보드, 마우스 갈아 끼우듯이
- 컴퓨터 부품 갈아 끼우듯이
- 컴포넌트를 쉽고 유연하게 변경하면서 개발할 수 있는 방법

## 다형성 (Polymorphism)

### 다형성의 실세계 비유

- 실세계와 객체 지향을 1:1로 매칭 X
- 그래도 실세계의 비유로 이해하기에는 좋음
- `역할`과 `구현`으로 세상을 구분
    - 예: 운전자 - 자동차
    - 운전자 역할 → 자동차 역할 ← 자동차 구현 (K3, K5, K8 …)
    - 자동차가 바뀌어도 운전자에게 영향을 주지 않는다. (똑같이 운전 가능. 차가 변경된다고 새로운 면허가 필요하지 않음.)
    - 운전자 = 클라이언트. 운전자가 자동차의 내부 구조를 몰라도 됨. 내부적으로 변경되더라도 운전자에게 영향을 주지 않음. 따라서, 자동차 세상을 무한히 확장 가능.
- 클라이언트에 영향을 주지 않고 새로운 기능을 제공할 수 있음.

### 역할과 구현을 분리

- `역할`과 `구현`으로 구분하면 세상이 `단순`해지고, `유연`해지며 `변경`도 편리해진다.
- 장점
    - 클라이언트는 대상의 역할(인터페이스)만 알면 된다.
    - 클라이언트는 구현 대상의 **내부 구조를 몰라도** 된다.
    - 클라이언트는 구현 대상의 **내부 구조가 변경**되어도 영향을 받지 않는다.
    - 클라이언트는 **구현 대상 자체를 변경**해도 영향을 받지 않는다.

자바 언어

- 자바 언어의 다형성을 활용
    - 역할 = 인터페이스
    - 구현 = 인터페이스를 구현한 클래스, 구현 객체
- 객체를 설계할 때 `역할`과 `구현`을 명확히 분리
- 객체 설계 시 역할(인터페이스)을 먼저 부여하고, 그 역할을 수행하는 구현 객체 만들기
    - 핵심은 다형성은 구현보다 역할. 인터페이스를 만드는 것이 더 중요함.

### 객체의 협력이라는 관계부터 생각하기

- 혼자 있는 객체는 없다.
    - 예시: 클라이언트(요청), 서버(응답)
- 수 많은 객체 클라이언트와 객체 서버는 서로 협력 관계를 가진다.

![스크린샷 2024-05-04 013417](https://github.com/10000-Bagger/free-topic-study/assets/34956359/a2ddbdf9-4e71-4720-b158-db9508dea59f)


### 자바 언어의 다형성
![스크린샷 2024-05-04 013445](https://github.com/10000-Bagger/free-topic-study/assets/34956359/2a1e5a5b-0763-4002-819f-4222e7aaeaf3)


- 오버라이딩을 떠올려보자
- 오버라이딩은 자바 기본 문법
    - Overloading: 두 메서드가 같은 이름을 가지고 있으나 인자의 수나 자료형이 다른 경우 = 메서드를 여러개 정의한다.
    - Overriding: 상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것 = 메서드를 재정의한다.
- 오버라이딩 된 메서드가 실행
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경할 수 있다.
- 물론 클래스 상속 관계도 다형성, 오버라이딩 적용 가능

```java
public class MemberService {
    private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

```java
public class MemberService {
    private MemberRepository memberRespository = new JdbcMemberRepository();
}
```

### 다형성의 본질

- 인터페이스를 구현한 객체 인스턴스를 `실행 시점`에 `유연`하게 `변경`할 수 있다.
- 다형성의 본질을 이해하려면 `협력`이라는 객체 사이의 관계에서 시작해야 함.
- **클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경할 수 있다.**

### 역할과 구현을 분리 (정리)

- 실세계의 역할과 구현이라는 편리한 컨셉을 다형성을 통해 객체 세상으로 가져올 수 있음.
- 유연하고, 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경 가능
- **인터페이스를 안정적으로 잘 설계하는 것이 중요**

### 역할과 구현을 분리 (한계)

- 역할(인터페이스) 자체가 변하면, 클라이언트, 서버 모두에 큰 변경이 발생한다.
    - 자동차를 비행기로 변경해야 한다면?
    - 연극의 대본 자체가 변경된다면?
    - USB 인터페이스가 변경된다면?
- 따라서 **인터페이스를 안정적으로(가장 변경이 없도록) 잘 설계하는 것이 중요 ****

### 스프링과 객체 지향

- **다형성이 가장 중요하다!**
- 스프링은 다형성을 극대화해서 이용할 수 있게 도와준다.
- 스프링에서 이야기하는 제어의 역전(IoC), 의존관계 주입(DI)은 다형성을 활용해서 역할과 구현을 편리하게 다룰 수 있도록 지원한다.
- 스프링을 사용하면 마치 레고 블럭 조립하듯이, 공연 무대의 배우를 선택하듯이 구현을 편리하게 변경할 수 있다.

## 좋은 객체 지향 설계의 5가지 원칙 (SOLID)

### SOLID

클린 코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리

- SRP: 단일 책임 원칙(Single Responsibility Principle)
- OCP: 개방-폐쇠 원칙(Open/Closed Principle)
- LSP: 리스코프 치환 원칙(Liskov substitution principle)
- ISP: 인터페이스 분리 원칙(Interface Segregation Principle)
- DIP: 의존관계 역전 원칙(Dependency Inversion Principle)

### SRP: 단일 책임 원칙

- 한 클래스는 하나의 책임만 가져야 한다.
- 하지만, 하나의 책임이라는 것은 모호하다.
    - 클 수도 있고, 작을 수도 있다.
    - 문맥과 상황에 따라 다르다.
- **중요한 기준은 `변경`**이다. 변경이 있을 때 파급 효과가 적으면 단일 책임 원칙을 잘 따른 것.
    - 예: UI 변경, 객체의 생성과 사용을 분리

### OCP: 개방-폐쇄 원칙 **

- 소프트웨어 요소는 **확장에는 열려** 있으나 **변경에는 닫혀** 있어야 한다.
- 확장을 하려면, 당연히 기존 코드를 변경? → 다형성을 활요해보자.
- 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현
- 역할과 구현의 분리를 생각하기

### OCP: 개방-폐쇄 원칙 (문제점)

```java
public class MemberService {
//  private MemberRepository memberRepository = new MemoryMemberRepository();
    private MemberRepository memberRepository = new MemoryMemberRepository();
}
```

- MemberService 클라이언트가 구현 클래스를 직접 선택
    - MemberRepository m = new MemoryMemberRepository(); // 기존 코드
    - MemberRepository m = new JdbcMemberRepository(); // 변경 코드
- **구현 객체를 변경하려면 클라이언트 코드를 변경해야 한다.**
- **분명 다형성을 사용했지만 OCP 원칙을 지킬 수 없다.**
- 이 문제를 어떻게 해결해야 하나? ← **객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다. ← 스프링 컨테이너의 역할**

### LSP: 리스코프 치환 원칙

- 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
- 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙, 인터페이스를 구현한 구현체를 믿고 사용하려면 이 원칙이 필요하다.
- 단순히 컴파일에 성공하는 것을 넘어서는 이야기
    - 예: 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현하면 LSP 위반, 느리더라도 앞으로 가야 함.

### ISP: 인터페이스 분리 원칙

- 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다.
- 자동차 인터페이스 → 운전 인터페이스, 정비 인터페이스로 분리
- 사용자 클라이언트 → 운전자 클라이언트, 정비사 클라이언트로 분리
- 분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음
- 인터페이스가 명확해지고, 대체 가능성이 높아진다.

### DIP: 의존관계 역전 원칙 **

- 프로그래머는 “추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나다.
- 쉽게 이야기해서 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻
    - 예: 클라이언트가 MemberRepository를 봐야지 JdbcMemberRepository를 바라보면 안됨.
- 앞에서 이야기한 **역할(Role)에 의존하게 해야 한다는 것과 같다**. 객체 세상도 클라이언트가 인터페이스에 의존해야 유연하게 구현체를 변경할 수 있다. 구현체에 의존하게 되면 변경이 아주 어려워진다.

### 정리

- 객체 지향의 핵심은 다형성
- 다형성 만으로는 쉽게 부품을 갈아 끼우듯이 개발할 수 없다.
- 다형성 만으로는 구현 객체를 변경할 때 클라이언트 코드도 함께 변경된다.
- 다형성 만으로는 OCP, DIP를 지킬 수 없다.
- 원가 더 필요하다. ← 스프링

## 객체 지향 설계와 스프링

### 다시 스프링으로

스프링 이야기에 왜 객체 지향 이야기가 나오는가?

- 스프링은 다음 기술로 다형성 + OCP, DIP를 가능하게 지원
    - DI(Dependency Injection): 의존관계, 의존성 주입
    - DI 컨테이너 제공
- **클라이언트 코드의 변경 없이 기능 확장**
- 쉽게 부품을 교체하듯이 개발

스프링이 없던 시절…

- 순수하게 자바로 OCP, DIP 원칙들을 지키면서 개발을 해보면, 결국 스프링 프레임워크를 만들게 된다. (더 정확히는 DI 컨테이너)
- DI 개념은 말로 설명해도 이해하기 쉽지 않음. 코드로 짜봐야 필요성을 알게 됨.
- 다음 섹션에서 스프링이 왜 만들어졌는지 코드로 이해해보자

### 정리

- 모든 설계에 역할과 구현을 분리하자.
    - 자동차, 공연의 예를 떠올려라.
- 애플리케이션 설계도 공연을 하듯이 배역만 만들어두고, 배우는 언제든지 유연하게 변경할 수 있도록 만드는 것이 좋은 객체 지향 설계다. (다형성 + OCP, DIP)
- 이상적으로는 모든 설계에 인터페이스를 부여하자.

실무 고민

- 하지만 인터페이스를 도입하면 추상화라는 비용이 발생한다.
- 기능을 확장할 가능성이 없다면, 구현 클래스를 직접 사용하고, 향후 꼭 필요할 때 리팩터링해서 인터페이스를 도입하는 것도 방법이다.
