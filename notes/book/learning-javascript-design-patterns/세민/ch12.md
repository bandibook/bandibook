## 고차 컴포넌트 패턴

고차 컴포넌트는 컴포넌트를 인자로 받아 새로운 컴포넌트를 반환하는 함수이다. 즉, **컴포넌트를 입력받아, 기능이 추가된 새로운 컴포넌트를 반환**하는 패턴

### 예시 코드

```jsx
// 로딩 고차 컴포넌트
function withLoading(Component) {
  return function WithLoadingComponent({ isLoading, ...props }) {
    if (isLoading) {
      return <div>로딩 중...</div>;
    }
    return <Component {...props} />;
  };
}

// 원본 컴포넌트
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => <li key={user.id}>{user.name}</li>)}
    </ul>
  );
}

const UserListWithLoading = withLoading(UserList);

<UserListWithLoading isLoading={true} users={[]} />
```

### 장점

1. **코드 재사용성 증가**  
   여러 컴포넌트에 공통 기능(로딩, 인증, 데이터 fetch 등)을 쉽게 추가할 수 있다.
2. **관심사 분리**  
   UI와 로직을 분리하여 관리할 수 있다.
3. **컴포넌트 조합의 유연성**  
   여러 HOC를 조합하여 다양한 기능을 손쉽게 추가할 수 있다.


### 단점

1. **Props 전달 혼란**  
   HOC가 여러 개 중첩되면 props 전달이 복잡해질 수 있다.
2. **디버깅 어려움**  
   HOC로 감싸진 컴포넌트의 이름이 바뀌거나, React DevTools에서 추적이 어려울 수 있다.
3. **Wrapper Hell**  
   HOC가 중첩될수록 코드가 복잡해지고, 가독성이 떨어질 수 있다.

### 개인적인 생각

기능적인 측면에서는 로딩 상태의 책임이 있는 widthLoading 고차 컴포넌트가 그나마 사용할만 하지 않나.. emotion, styled-components 등 styled() 를 통해 스타일링 고차 컴포넌트는 자주 사용하는 듯.

## 렌더 Props 패턴

렌더 Props 패턴은 컴포넌트의 children이나 특정 prop에 함수를 전달하여, 그 함수로부터 UI를 렌더링하는 패턴이다. 즉, **컴포넌트의 렌더링 로직을 외부에서 주입받아 동적으로 UI를 구성**하는 방식이다.

### 예시 코드

```jsx
function DataLoader({ render }) {

  const [data, setData] = React.useState(null);

  useEffect(() => {
    setTimeout(() => {
      setData(["철수", "영희"]);
    }, 1000);
  }, []);

  return render(data);
}

<DataLoader render={data => (
  data ? <ul>{data.map(name => <li key={name}>{name}</li>)}</ul> : <div>로딩 중...</div>
)} />
```

### 장점

1. **유연한 조합**  
   다양한 UI를 외부에서 주입하여 재사용성과 확장성이 높다.

### 단점

1. **코드 가독성 저하**  
   중첩된 함수형 children이 많아지면 코드가 복잡해질 수 있다. Wrapper Hell.
2. **불필요한 렌더링**  
   렌더 함수가 새로 생성될 때마다 하위 컴포넌트가 리렌더링될 수 있다.

### 개인적인 생각

개인적으로는 children prop을 더 많이 사용함. 하지만 최근에 Input 공통 컴포넌트를 만들 때 input 내부에 좌측 또는 우측 icon을 넣고자 할 떄 `leftIcon`, `rightIcon` prop을 열어 render 패턴을 사용했었음. 개인적으론 children 으로 해결이 어려운 상황에 차선책으로 사용하는 듯.

## React Hooks 패턴

React Hooks 패턴은 함수형 컴포넌트에서 상태 관리와 사이드 이펙트, 재사용 가능한 로직을 구현하기 위해 사용하는 패턴이다. Hook은 함수 내부에서 React의 기능을 사용할 수 있게 해주는 함수이다.

### 예시 코드

```jsx
function useUserData() {
  const [data, setData] = React.useState(null);

  useEffect(() => {
    setTimeout(() => {
      setData(["철수", "영희"]);
    }, 1000);
  }, []);

  return data;
}

function UserList() {
  const data = useUserData();

  if (!data) return <div>로딩 중...</div>;

  return (
    <ul>
      {data.map(name => <li key={name}>{name}</li>)}
    </ul>
  );
}
```

### 장점

1. **로직 재사용성**  
   커스텀 훅을 통해 여러 컴포넌트에서 동일한 로직을 쉽게 재사용할 수 있다.
2. **코드 구조 단순화**  
   클래스 없이 함수형 컴포넌트만으로 상태와 라이프사이클을 관리할 수 있다.
3. **관심사 분리**  
   UI와 비즈니스 로직을 분리하여 관리할 수 있다.

### 단점

1. **Hook 규칙 제약**  
   훅은 반드시 최상위에서만 호출해야 하며, 조건문이나 반복문에서 사용할 수 없다.
2. **무분별한 사이드 이펙트 사용으로 추적이 어려움**  
   여러 훅이 중첩되면 상태 변화나 사이드 이펙트 추적이 어려울 수 있다.

### 개인적인 생각

사실상 React의 꽃이지 않나.. 라이프사이클 단순화부터 UI와 feature의 관심사 분리가 용이해지고, 가독성을 (유독 심하게) 해치는 this를 사용하지 않아도 된다는 점에서 상당히 편리해졌다고 생각한다. 다만, 너무 많은 기능을 합친 슈퍼 커스텀 훅이나 useEffect 남발은 코드 가독성을 더욱 떨어뜨리고 결과를 예측하기 더 어렵게 만드는 것 같다.

## 정적 import 동적 import

정적 import는 모듈을 코드 상단에서 미리 선언하여 전체 코드 실행 전에 한 번에 불러오는 방식이다. 동적 import는 코드 실행 중 필요한 시점에 모듈을 불러오는 방식이다.

### 예시 코드

```js
// 정적 import
import _ from 'lodash';

// 동적 import
async function loadLodash() {
  const _ = await import('lodash');
  console.log(_.chunk([1,2,3,4], 2));
}

// 동적으로 import (lazy)
import { lazy, Suspense } from 'react';

const UserList = lazy(() => import('./UserList'));

function App() {
  return (
    <Suspense fallback={<div>로딩 중...</div>}>
      <UserList />
    </Suspense>
  );
}
```

### 장점

#### 정적 import
1. **코드 가독성**  
   의존성을 코드 상단에서 한눈에 파악할 수 있다.
2. **트리 쉐이킹**  
   빌드 시 사용하지 않는 코드가 제거되어 번들 크기가 최적화된다.
3. **IDE 지원**  
   자동 완성, 타입 추론 등 개발 도구의 지원을 받을 수 있다.

#### 동적 import
1. **코드 분할**  
   필요할 때만 모듈을 불러와 초기 로딩 속도를 개선할 수 있다. (코드 스플릿팅)
2. **조건부 로딩**  
   특정 상황에서만 모듈을 불러올 수 있다.

### 단점

#### 정적 import
1. **초기 로딩 지연**  
   모든 모듈을 한 번에 불러와 초기 로딩 속도가 느려질 수 있다.
2. **불필요한 코드 포함**  
   실제로 사용하지 않는 모듈도 번들에 포함될 수 있다.

#### 동적 import
1. **코드 가독성 저하**  
   import 위치가 분산되어 의존성 파악이 어렵다.
2. **런타임 에러**  
   모듈 로딩 실패 시 런타임 에러가 발생할 수 있다.
3. **트리 쉐이킹 한계**  
   동적으로 import한 모듈은 트리 쉐이킹이 제한적이다.

### 개인적인 생각

동적 import 는 보통 코드 스플릿팅할 때 한 번씩 써보는 것 같다. Suspense 와 lazy 를 통한 동적 import를 주로 사용하는 것 같다. 다만, 동적 import를 통한 코드 스플릿팅이 LCP 개선에 도움이 되는 것은 맞지만 크게 도움이 되는지는 조금 의아하다. 개인적으론 이미지 최적화가 더 큰 LCP 개선에 영향이 있지 않을까..

## PRPL 패턴

PRPL 패턴은 웹 애플리케이션의 로딩 성능을 최적화하기 위한 전략이다. Google에서 제안한 패턴으로, 빠른 초기 로딩과 사용자 경험 개선을 목표로 한다.

### PRPL의 의미

- **P**ush: 중요한 리소스를 HTTP/2 Push 등으로 미리 전송한다.
- **R**ender: 초기 라우트(뷰)를 빠르게 렌더링한다.
- **P**re-cache: 나머지 라우트에 필요한 리소스를 백그라운드에서 미리 캐싱한다.
- **L**azy-load: 사용자가 필요로 할 때 추가 리소스를 지연 로딩한다.

### 예시

1. 메인 페이지에 필요한 JS/CSS만 우선적으로 번들에 포함한다.
2. Service Worker를 통해 나머지 라우트의 리소스를 백그라운드에서 미리 캐싱한다.
3. 사용자가 다른 라우트로 이동할 때 해당 리소스를 즉시 사용할 수 있도록 한다.
4. 실제로 필요한 시점에만 추가적인 JS 번들을 lazy-load 한다.

### 장점

1. **초기 로딩 속도 개선**  
   중요한 리소스만 먼저 받아오므로 첫 화면이 빠르게 보인다.
2. **사용자 경험 향상**  
   라우트 전환 시 대기 시간이 줄어든다.
3. **네트워크 효율성**  
   불필요한 리소드 다운로드를 줄일 수 있다.

### 단점

1. **구현 복잡성**  
   Service Worker, 코드 스플릿팅 등 다양한 기술을 함께 사용해야 한다.
2. **브라우저 호환성**  
   HTTP/2 Push, Service Worker 등 일부 기술은 구형 브라우저에서 지원되지 않는다.
3. **캐싱 관리 어려움**  
   리소스 버전 관리와 캐시 무효화 전략이 필요하다.

### 개인적인 생각

음.. 저사양 기기를 위한 패턴인 것 같은데 처음 본다. 요즘 스마트 안경? 이런 것들도 나오던데 저사양 스마트폰보다는 저사양 IoT나 악세사리에 브라우저 기능이 들어간다면 도입해볼만한 기능이지 않을까..

## 로딩에 대하여

웹에서 리소스 로딩을 최적화하기 위해 다양한 방법이 존재한다. 대표적으로 prefetch, preload, async, defer 속성이 있다.

### prefetch

- **개념**: 추후에 필요할 리소스를 미리 백그라운드에서 받아오는 방식이다. (캐싱)
- **예시**:
  ```html
  <link rel="prefetch" href="/next-page.js" />
  ```
- **장점**: 사용자가 실제로 해당 리소스를 필요로 할 때 빠르게 제공할 수 있다.
- **단점**: 불필요한 리소스까지 미리 받아 네트워크 자원을 낭비할 수 있다.
- **개인적인 생각**: 페이지 이동이 잦은 SPA에서 유용하게 사용할 수 있다고 생각

### preload

- **개념**: 현재 페이지 렌더링에 꼭 필요한 리소스를 우선적으로 받아오는 방식이다.
- **예시**:
  ```html
  <link rel="preload" href="/main.css" as="style" />
  ```
- **장점**: 렌더링에 중요한 리소스를 빠르게 받아 초기 화면 표시 속도를 높일 수 있다.
- **단점**: 우선순위가 높아 네트워크가 혼잡할 때 다른 리소스 로딩이 지연될 수 있다.
- **개인적인 생각**: LCP 개선에 효과적이지만, 남발하면 오히려 성능이 저하될 수 있다고 생각한다. (잘써야지..)

### async

- **개념**: script 태그에 사용하며, HTML 파싱과 동시에 비동기로 JS를 다운로드하고, 다운로드가 끝나면 바로 실행하는 방식이다.
- **예시**:
  ```html
  <script src="/analytics.js" async></script>
  ```
- **장점**: HTML 파싱을 막지 않아 렌더링이 지연되지 않는다.
- **단점**: 실행 순서가 보장되지 않아, 의존성이 있는 스크립트에는 부적합하다.
- **개인적인 생각**: 외부 라이브러리나 분석 스크립트에 주로 사용하는 것이 적합 (카카오 공유하기 기능 SDK나 등등..)

### defer

- **개념**: script 태그에 사용하며, HTML 파싱과 동시에 JS를 다운로드하지만, HTML 파싱이 끝난 후에 실행하는 방식이다.
- **예시**:
  ```html
  <script src="/main.js" defer></script>
  ```
- **장점**: HTML 파싱이 끝난 뒤에 실행되어 렌더링을 방해하지 않는다. 여러 defer 스크립트의 실행 순서가 보장된다.
- **단점**: 오래된 브라우저에서는 지원이 완벽하지 않을 수 있다.
- **개인적인 생각**: 메인 스크립트나 의존성이 있는 스크립트에 적합하다고 생각한다. async와 달리 실행 순서가 보장되어 안정적이고, HTML 파싱을 방해하지 않아 초기 렌더링도 빠르다. 요즘은 대부분의 모던 브라우저가 지원하므로 적극적으로 사용해도 좋을 것 같다는 생각.
