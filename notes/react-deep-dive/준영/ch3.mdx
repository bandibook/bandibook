> **훅**

- 함수 컴포넌트가 상태를 사용하거나 클래스 컴포넌트의 생명주기 메서드를 대체하는 등 다양한 작업을 하기 위한 장치
- 클래스 컴포넌트에서만 가능했던 state, ref 등 리액트 핵심 기능을 함수에서도 사용할 수 있도록 해준다.
- 무엇보다 간결하게 작성할 수 있다.

> **함수 내부에 일반 변수를 사용할 경우, 왜 렌더링이 일어나지 않을까?**

- 리액트에서는 함수 컴포넌트의 return 혹은 클래스 컴포넌트의 render 함수를 실행하여 현재 DOM과 가상 DOM을 비교하여 변경된 부분에 대해서만 리렌더링을 한다.
- 하지만 일반 변수를 사용할 경우, 리액트에서는 업데이트를 인지하지 못하여 렌더링이 일어나지 않는다.
- 또한 함수 컴포넌트에서 일반 변수와 함께 상태 업데이트 함수를 사용하여 리렌더링을 일으키더라도 변경된 값이 렌더링되지 않는다.
  - 그 이유는 **렌더링시 함수는 새롭게 다시 실행**되기 때문에 매번 같은 값으로 초기화되어 렌더링이 일어나지 않는 것이다.

> **useState**

- 함수 컴포넌트에서 상태를 관리할 수 있게 해주는 훅
- 매번 실행되는 함수 컴포넌트 환경에서 state의 값을 유지하고 사용하기 위해 **클로저로 구현**되어 있다.
  - 따라서 **외부에 상태 값을 노출시키지 않고** 리액트 내부에서만 사용할 수 있고, 매번 다시 실행되더라도 **정확하게 이전의 값을 꺼내 사용**할 수 있다.

> **게으른 초기화 (Lazy Initialization)**

- `useState`의 인수로 특정한 값을 반환하는 함수를 넣어 사용할 수 있다.
- 오로지 state가 **처음 만들어질 때에만 사용**되고, 이후에 리렌더링이 될 때에는 실행하지 않고 기존에 실행하여 저장된 값을 가져온다.

> **언제 사용하는 것이 좋을까?**

- `useState`의 **초깃값이 복잡하거나 무거운 연산을 포함하는 경우**에 사용하는 것을 권장한다고 한다.
  - localStorage나 sessionStorage에 대한 접근
  - map, filter, find 같은 배열에 대한 접근
  - …

> **useEffect**

- 컴포넌트의 여러 값들을 활용하여 부수 효과를 만드는 훅
  - 첫 번째 파라미터: 부수 효과가 포함된 함수
  - 두 번째 파라미터: 의존성 배열

> **어떻게 의존성 배열이 변경된 것을 알고 실행될까?**

- 함수 컴포넌트는 state나 props에 **변경이 생길 때마다 매번 함수를 실행시켜 렌더링을 수행**한다.
- 의존성 배열의 **이전 값과 현재 값의 얕은 비교**, 즉, `Object.is`를 통해 수행된다.

  ✅ **파이버를 통해 변경사항을 수집**하게 되고, 이때 **의존성 배열에 포함된 값이 수정되었다면** 부수 효과를 일으킬 수 있도록 실행되는 것이 아닐까?

  ✅ 알아보니 아닌 것 같다. 두 사이에는 관계가 없는듯..? 좀더 알아봐야겠다.

> **클린업 함수**

- 함수 컴포넌트가 리렌더링되었을 때 의존성 변화가 있었다면, **함수가 정의되었을 때의 값을 기준으로 실행**되는 함수
- useEffect의 **return 값**으로 전달된다.
- 일반적으로 등록한 이벤트를 지울 때 사용

> **의존성 배열**

- 다음과 같은 배열이 들어갈 수 있다.
  - 빈 배열
    - 비교할 의존성이 없다.
    - 즉, 최초 렌더링 이후 더 이상 실행되지 않는다.
  - 아무런 값도 넣지 않음
    - 렌더링될 때마다 실행이 필요하다.
    - 즉, 매 렌더링마다 실행된다.
  - 사용자가 원하는 값을 넣은 배열
    - 의존성으로 넣어준 값들이 변경되었을 때에만 실행된다.

> **의존성 배열에 아무런 값도 넣지 않으면 컴포넌트 내부에서 함수를 실행시키는 것과 같지 않나?**

- useEffect는 클라이언트 사이드에서 실행이 보장된다.
- useEffect는 컴포넌트 **렌더링이 완료된 이후에 실행**되지만, 내부에서 실행시키는 함수는 **렌더링되는 도중에 실행**된다.
  - 따라서 렌더링을 **지연**시킬 수 있다.

> **useEffect 사용시 주의할 점**

- `eslint-disble-line-react-hooks/exhaustive-deps` 주석 피하기
  - 의존성 배열에 포함돼 있지 않은 값이 있을때 의도치 못한 버그를 발생시킬 수 있다.
- useEffect의 첫 번째 인수에 함수명을 부여하라
  - useEffect의 첫 번째 인수로 넘긴 함수의 크기가 커질 경우, 의도를 파악하기 어려울 수 있으니 함수명을 부여한다면 목적을 파악하기 수월해질 수 있다.
- 거대한 useEffect를 만들지 마라
  - 부수 효과가 커질수록 성능에 악영향을 끼친다.
    - 자바스크립트 실행 성능에 영향을 미치기 떄문
  - 최대한 작게 분리하여 만들자.
- 불필요한 외부 함수를 만들지 마라
  - 관련 함수는 내부로 가져와 작성하는 것이 훨씬 간결할 수 있다.

> **useEffect의 Callback에 비동기 함수를 넣었을때 발생할 수 있는 문제점**

- 비동기 함수의 응답 속도에 따라 결과가 이상하게 나타날 수 있다.
  - 이전 state 기반 응답이 10초, 이후 state 기반 응답이 1초 뒤에 왔다면, 이전 state 기반 응답으로 인한 결과가 나와버려 원하는 결과를 얻지 못할 수 있다.
    - 즉, `Race condition`이 발생할 수 있다.
- 따라서, useEffect 내부에서 비동기 함수를 실행하거나 즉시 실행 함수를 통해 사용하자!

> **useMemo**

- 비용이 큰 연산에 대한 결과를 저장해두고, 해당 값을 반환하는 훅
  - 첫 번째 파라미터: 값을 반환하는 함수
  - 두 번째 파라미터: 의존성 배열
- useEffect와 마찬가지로 의존성 배열이 변하지 않는 한 이미 저장되어있는 값을 반환한다.
- 값 뿐만 아니라 컴포넌트를 저장할 수도 있다.
  - 물론 `React.memo`를 사용하는 쪽이 더 좋다.

> **useCallback**

- useMemo와 비슷하지만, 인수로 넘겨받은 콜백 자체를 기억한다.
  - 즉, 특정 함수를 **재사용**한다.
- useMemo를 통해 구현이 가능하다. (실제로 그렇게 구현되어 있던 것으로 기억)

> **useRef**

- 컴포넌트가 렌더링될 때 생성되어 특정 값을 저장한다.
  - 인스턴스가 여러 개라도 각각 별개의 값을 바라본다(?)
- 반환 값인 객체 내부의 current로 값에 접근 혹은 변경이 가능하다.
- useRef는 값이 변하더라도 **렌더링을 발생시키지 않는다.**
- 보통 DOM에 접근하기 위해 사용한다.

> **Context**

- 특정 데이터를 자식에서도 사용하기 위해선 props로 데이터를 전달하는 것이 일반적이다.
- 하지만 이러한 컴포넌트간 거리가 멀어질 경우, 코드는 복잡해진다.
  - 조상 ~ 자식까지 계속해서 props를 통해 데이터를 전달해야 하는데, 이를 `props drilling` 이라고 한다.
  - 따라서 중간에 해당 데이터를 사용하지 않는 컴포넌트도 drilling을 위해 props로 데이터를 갖고 있어야 하므로 매우 비효율 적이다.
- 이를 해결하기 위해 등장한 개념이 `Context`이다.

> **useContext**

- Context와 해당 Context를 함수 컴포넌트에서 사용할 수 있게 해주는 훅
- 가까운 Provider에 존재하는 값을 가져온다.
  - 만약 정의된 Provider가 없다면 undefined가 반환되며 이를 미리 걸러낼 수 있도록 별도의 함수로 감싸 사용하는 것이 좋다.

> **useContext 사용시 주의할 점**

- useContext를 사용한 순간부터 **Provider와의 의존성**이 생긴다.
  - 즉, **재활용하기 어려워질 수 있다.**
  - 따라서, Context가 미치는 범위를 필요한 환경 내에서 **최대한 좁게** 만들어야 한다.
- Context가 상태 관리 라이브러리는 아니다.
  - 따라서 별다른 렌더링 최적화를 해주지 않기 때문에, 이를 위한 별도의 처리가 필요하다.
  - 부모 컴포넌트가 렌더링되었을 때 자식 컴포넌트의 리렌더링 또한 일어나기 때문에, `React.memo`를 사용하는 등의 최적화 장치가 필요하다.

> **useReducer**

- useState와 마찬가지로 상태를 정의하는 훅
  - `action`을 통해 상태 변화를 일으키는 타입들을 정의
  - `reducer`를 통해 어떤 `action`이 상태를 어떻게 업데이트할 지를 정의
  - 따라서, `dispatcher`를 통해 `action`을 `reducer`에 전달하면 상태가 업데이트
- 상태 업데이트를 `dispatcher`로 제한할 수 있기 때문에 **상태 변경 시나리오가 특정되는 경우** 사용하면 좋다.

> **forwardRef**

- `ref`를 전달하는데 있어 일관성을 제공하기 위해 탄생
- `ref`를 전달 받는 요소임을 확실하게 예측할 수 있다.

> **useImperativeHandle**

- 넘겨 받은 `ref`에 **동작을 추가**할 수 있는 훅

  - 원래 ref는 `{ current: <HTMLElement> }`와 같은 형태지만, 해당 훅을 통해 추가적인 동작을 정의할 수 있다.

    ```jsx
    useImperativeHandle(
      ref,
      () => ({
        alert: () => alert(props.value),
      }),
      [props.value],
    );

    /* ... */

    inputRef.current.alert(); // 추가한 동작을 사용할 수 있다.
    ```

> **useLayoutEffect**

- 함수 시그니처는 useEffect와 동일하나, 모든 DOM의 변경 후에 동기적으로 발생하는 훅
  - 여기서 말하는 DOM 변경이란, 브라우저에 실제 반영되는 렌더링이 아닌 **리액트의 렌더링**이다.
  - 실행 순서는 아래와 같다.
    1. 리액트가 DOM을 업데이트
    2. **useLayoutEffect 실행**
    3. 브라우저에 변경 사항을 반영
    4. **useEffect 실행**
- 따라서, DOM은 계산되었지만, **화면에 반영하기 전 수행하고 싶은 작업이 있을 때** 사용하면 자연스러운 사용자 경험을 제공할 수 있다.
  - DOM 요소를 기반으로 한 애니메이션
  - 스크롤 위치 제어
  - …

> **useDebugValue**

- 디버깅하고 싶은 정보를 해당 훅에 사용하여 리액트 개발자 도구에서 확인할 수 있다.
  - 사용자 정의 훅 내부의 내용에 대한 정보를 담아 확인할 수 있다.
  - 오직 다른 훅의 내부에 사용 가능하다.

> **훅의 규칙**

- 아래 규칙을 만족해야만 컴포넌트가 렌더링될 때마다 **항상 동일한 순서로 훅이 호출**되는 것을 보장할 수 있다.
  - **최상위에서만 훅을 호출해야 한다.**
  - **반복문이나 조건문, 중첩된 함수 내에서 훅을 실행할 수 없다.**
- 훅들은 리액트 어딘가에 있는 `index`와 같은 **키를 기반으로 구현되어 순서에 아주 큰 영향**을 받는다.
  - 파이버에서는 `next`라는 속성을 통해 다음에 처리될 훅을 순서에 따라 **링크드 리스트 형태로 저장**한다.
    - 순서에 의존하여 `state`나 `effect`의 **결과에 대한 값을 저장**하고, 이를 통해 이**전 값과 비교와 실행**이 가능하다.
- 따라서 순서가 보장되지 않는다면 에러를 일으킨다.
- 조건문이 필요할 경우, 훅 내부에서 수행하자!

> **사용자 정의 훅**

- 서로 다른 컴포넌트 내부에서 같은 **로직을 공유하고자 할 때** 주로 사용한다.
- 리액트 훅을 사용하기 때문에 리액트에서만 사용이 가능하며 규칙을 따라야 한다.

> **고차 컴포넌트**

- **컴포넌트 자체의 로직을 재사용**하기 위한 방법이다.
- 고차 함수의 일종으로, 자바스크립트의 일급 객체, 함수의 특징을 이용하여 리액트가 아니더라도 쓰일 수 있다.

> **React.memo**

- `props` **변화가 없음에도 발생하는 컴포넌트의 렌더링을 방지**하기 위해 만들어진 리액트의 고차 컴포넌트
- `props`가 같다면 메모이제이션된 컴포넌트를 반환한다.
- `useMemo`를 사용할 수도 있지만, 할당식을 사용해야 하기도 하고, 보다 목적과 용도가 뚜렷한 `memo`를 사용하자.

> **사용자 정의 훅이 필요한 경우**

- 공통 로직을 따로 분리할 때 사용하는 것이 좋다.
- 렌더링에는 영향을 미치지 못하기 때문에 사용이 제한적이며, 따라서 컴포넌트 내부에 미치는 영향을 최소화하여 개발자가 원하는 방향으로 사용할 수 있다.

✅ 렌더링 자체는 컴포넌트 함수 실행으로 이루어진다.
따라서 단순히 복잡한 로직을 선언형으로 만들어 값을 제공하는 용도로만 사용되어 컴포넌트 안에서 개발자가 자유롭게 다룰 수 있어 이렇게 설명한 것 같다.

> **고차 컴포넌트를 사용해야 하는 경우**

- 렌더링의 결과물에도 영향을 미치는 공통 로직이라면 고차 컴포넌트를 사용하는 것이 좋다.

✅ 하나의 컴포넌트 내에서 특정 상황에 따라 보여주는 결과물이 다르다면, 고차 컴포넌트를 활용하여 렌더링을 하는 것이 좋다라고 설명하는 것 같다.
사용자 정의 훅만으로는 이를 표현하기에는 어렵기 때문이다.
