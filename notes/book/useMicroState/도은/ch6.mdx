### 전역 상태 관리 문제 해결하기

#### 전역 상태를 설계할 때 2가지 문제점

1. 전역 상태를 읽는 방법

- 전역 상태는 여러 값을 가질 수 있고
- 전역 상태를 사용하는 컴포넌트는 전역 상태의 일부만 필요할 수 있다.
- 전역 상태가 바뀌면 리렌더링이 일어나는데,
  - 일부만 사용하고 있는 컴포넌트고 뭐고 다 리렌더링이 발생
  - 바람직 X

2. 전역 상태에 값을 넣거나 갱신하는 방법

- 전역 상태는 충접된 객체일 수 있다.
- 이럴 때 전역 변수를 가지고 개발자가 직접 값을 변경하는 것은 좋은 방법이 아닐 수 있다.

  ```jsx
  globalVariable.b.d = 9;
  ```

  이렇게 변경할 경우, 이를 감지하고 컴포넌트를 리렌더링할 수 없다.

### 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

- 전역 상태는 **`데이터 중심`**과 **`컴포넌트 중심`**이라는 2가지 유형으로 구분

#### 1. 데이터 중심 접근 방식 이해하기

- 모듈 상태가 리액트 외부의 자바스크립트 메모리에 위치
- 모듈 상태는 리액트가 렌더링을 시작하기 전이나 모든 리액트 컴포넌트가 마운트 해제된 후에도 존재 가능
- 모듈 상태 생성 → 모듈 상태를 리액트 컴포넌트에 연결

#### 2. 컴포넌트 중심 방식 이해하기

- 데이터 모델이 컴포넌트에 강한 의존성을 가지고 있다.
- 전역 상태는 서로 다른 컴포넌트 하위 트리에 존재할 수 있다.

### 리렌더링 최적화

> 핵심은 컴포넌트에서 state의 **어느 부분이 사용될지 지정**하는 것

- `state`의 일부분을 지정하는 접근 방식
  - 선택자 함수 사용
  - 속성 접근 감지
  - 아톰 사용

#### 1. 선택자 함수 사용

- 선택자 함수는 상태를 받아 상태의 일부를 반환

```jsx
const Component = () => {
  const value = useSelector((state) => state.b.c);
  return <div>{value}</div>;
};
```

**📌 선택자와 메모이제이션에 대한 주요 사항**

- 선택자 함수가 반환하는 값이 숫자와 같은 원시 값이면 문제 X
- 선택자 함수가 **객체를 반환하는 경우 메모이제이션을 사용**하여
- 동일한 객체를 반환하도록 해야 한다.

#### 2. 속성 접근 감지

- 속성 접근을 감지하고, 감지한 정보를 렌더링 최적화 → **`상태 사용 추적(state usage tracking)`**

#### 3. 아톰 사용

- 아톰: 리렌더링을 발생시키는 데 사용되는 최소 상태 단위
- 전체 전역 상태를 구독해서 리렌더링을 피하는 대신 아톰을 사용하면 **좀 더 세분화해서 구독**하는 것이 가능

  ```jsx
  const globalState = {
    a: atom(1),
    b: atom(2),
    c: atom(3),
  };

  const Component = () => {
    const value = useAtom(globalState.a);
  };
  ```
