### 자바스크립트의 동등 비교

> **값 저장 방식의 차이**

`원시 타입`의 경우, **불변 형태**의 값으로 저장된다.<br/>
새로운 값을 할당할 경우, 새로운 메모리에 재할당된 값이 저장되고 변수가 이를 가리키게 된다.<br/>
원시 타입은 변수를 통해 값에 바로 접근이 가능하다.

하지만 `객체 타입`의 경우, 속성의 추가, 삭제, 수정과 같이 **변경 가능한 형태**로 저장된다.<br/>
객체 타입은 변수를 통해 참조에 접근이 가능하고, 참조를 통해 실제 값이 저장된 메모리에 도달해야 한다.

> **`Object.is` vs `==` vs `===`**

객체 비교시 `Object.is` 와 `===` 사이에 드라미틱한 차이는 없다.<br/>
`Object.is`는 ES6에서 추가되었다.

- `==` (Equal Operator)
  - 비교할 양쪽이 같은 타입이 아니라면 비교할 수 있도록 **형변환** 후 비교
- `===` (Strict Equal Operator)
  - 타입이 다를 경우 즉시 false
  - 어느 한쪽에라도 NaN이 존재하면 false
  - +0과 -0은 같다고 판단
- `Object.is`
  - 파라미터로 받는 두 인자가 동일한지 확인하는 메서드
  - +0과 -0은 다르다고 판단
  - NaN 비교 가능

> **리액트 컴포넌트의 렌더링이 일어나는 이유 중 하나는 `props의 동등 비교`에 따른 결과다.**

props 비교는 **객체의 얕은 비교**를 기반으로 이뤄진다.<br/>
기본적으로는 `Object.is` 를 사용하며, ES6를 지원하지 않는 브라우저를 위해 폴리필을 함께 사용한다.<br/>
`Object.is` 를 통해 먼저 비교 후, 앞의 과정에서 수행하지 못한 비교를 위해 객체의 속성을 모두 꺼내 값이 같은지 확인한다.

얕은 비교란, 객체의 첫 번째 깊이만을 비교한다는 것을 의미한다.<br/>
props에 또 다른 객체를 넘겨준다면 렌더링이 예상치 못하게 작동할 수 있기 때문이다.<br/>
추가적으로 만약 객체를 완벽하게 비교하기 위해 재귀적으로 비교를 수행한다면 성능에 악영향을 끼칠 것이다.

✅ 리렌더링이 발생하는 조건

- props의 변경
- 상태의 변경
- 부모 컴포넌트의 리렌더링
- key의 변화

> **함수**

- “작업을 수행하는 실행 단위”

> **함수 정의 방법**

1. 함수 선언문

   ```jsx
   function functionName(parameter) {
     /* ... */
   }
   ```

2. 함수 표현식

   ```jsx
   const functionName = function (parameter) {
     /* ... */
   };
   ```

3. Function 생성자

   - 다소 생소한 방식이며, 함수 전체를 텍스트로 작성해야 하므로 매우 불편함
   - 클로저가 생성되지 않는다.

   ```jsx
   const functionName = new Function('parameter', '/* ... */');
   ```

4. 화살표 함수

   - ES6에 추가됨

   ```jsx
   const functionName = (parameter) => {
     /* ... */
   };
   ```

> **“함수 선언문”과 “함수 표현식”의 차이**

“호이스팅”에 있어 차이가 있다.

함수 선언문의 경우, 호이스팅이 일어나 함수 선언 실행 전에 미리 메모리에 등록하는 작업이 진행된다.<br/>
따라서 함수 선언 위치보다 앞선 위치에서 함수를 호출하여도 정상 실행된다.

함수 표현식의 경우, 호이스팅이 일어나지만 변수에 함수를 담기 때문에 undefined로 초기화되거나, 초기화 단계가 미리 이루어지지 않기 때문에 함수 표현식의 위치보다 앞선 위치에서 실행할 경우 오류가 발생한다.

> **화살표 함수와 다른 함수 생성 방식과의 차이**

- 화살표 함수는 constructor를 사용할 수 없다.
- 화살표 함수에는 `arguments` 가 존재하지 않는다.
- 화살표 함수는 함수 자체의 바인딩을 갖지 않아 내부에서 `this` 참조시 상위 스코프의 this를 그대로 따른다.

> **즉시 실행 함수 (Immediately Invoked Function Expression, IIFE)**

함수를 정의하고, 그 즉시 실행되는 함수이다.<br/>
따라서 한 번만 호출될 뿐, 다시 호출할 수 없다.

일반적으로 실행 함수에 이름을 붙이지 않는다.

즉시 실행함수의 장점은 독립적인 함수 스코프를 운용할 수 있다는 것이다.<br/>
함수 선언과 실행이 바로 끝나기 때문에 함수 내부에 정의된 값은 해당 함수 외에는 접근이 불가능하다.

또한, 코드를 읽는 사람으로 하여금 해당 함수가 다시 호출되지 않음을 각인시켜줄 수 있다.

> **고차 함수**

자바스크립트의 함수가 일급 객체라는 특징을 활용해, 함수를 인수로 받거나 결과로 새로운 함수를 반환시킬 수 있다.<br/>
이러한 역할을 하는 함수가 `고차함수`이다.<br/>
이런 특징을 활용해 함수 컴포넌트를 파라미터로 받아 새로운 함수 컴포넌트를 반환하는 `고차 컴포넌트(HOC)`로 활용할 수 있다.

> **함수를 만들 때 주의해야할 사항**

- 부수효과는 보통 불가피하다~!
  - 따라서 최대한 부수효과를 최소화하자!
    - useEffect 사용을 최소화!

→ 항상 결과가 동일하여 예측 가능하고 안정적이라는 장점

- 가능한 작게 만들자
  - 코드 길이가 길어질수록 어떤 일을 하는지 추적이 어려워지고 리팩토링이 어려워진다.
- 재사용성을 높이자
- 누구나 이해할 수 있는 이름을 붙일 수 있도록 고민하자

### 클래스

> **클래스**

- 특정한 형태의 객체를 반복적으로 만들기 위한 템플릿
- 클래스는 자바스크립트의 `프로토타입`으로 작동한다.

### 클로저

> **스코프**

- 전역 스코프
  - 말그대로 전역에서 접근 가능한 스코프
  - 해당 스코프에서 변수를 선언할 경우, 전역 객체에 바인딩
    - 브라우저 - window
    - Node.js - global
- 함수 스코프
  - 자바스크립트는 기본적으로 함수 레벨 스코프를 따른다.
    - var의 경우, 선언된 {} 외부에서도 접근이 가능하다.
    - 이름이 같은 var로 선언된 변수의 경우, 가장 가까운 스코프에서부터 찾아나간다.
- 블록 스코프
  - var와 달리 let, const는 블록 레벨 스코프를 따른다.
  - {}이 생성될 때마다 새로운 스코프가 형성됨을 의미한다.

> **함수가 선언된 어휘적 환경**

함수 선언에 포함된 다른 변수나 함수들이 함수가 실행됨에 따라 실행 컨텍스트에 등록되고, return문을 통해 반환된 함수는 참조가 유지되어 가비지 컬렉션되지 않고 메모리에 남아있게 된다.<br/>
이때 반환된 함수를 클로저라고 부른다.<br/>
위 설명에서 함수가 선언되었을때 함수 내용에 포함된 다른 변수나 함수들을 “함수가 선언된 어휘적 환경”이라고 해석하였다.

> **위를 통해 얻을 수 있는 장점?**

만약 변수가 전역 레벨에 선언되어 있다면 누구나 수정할 수 있다는 문제점이 있다.<br/>
하지만, 클로저 내부에 존재하는 변수들은 외부에서 조작할 수 있는 방법이 없다. → 캡슐화<br/>
따라서 리액트가 관리하는 내부 상태 값은 리액트가 별도로 관리하는 클로저 내부에서만 접근할 수 있다.

대표적인 예시는 `useState`다.<br/>
useState 내부는 클로저가 활용되었다.<br/>
외부 함수인 `useState`가 반환한 내부 함수인 `setState`는 외부 함수가 종료되었음에도 **외부 함수가 선언된 환경을 기억하기 때문**에 `state` 값에 접근할 수 있는 것이다.

> **그럼 단점은?**

클로저 자체는 굉장히 어렵고 쉽지 않은 개념이다.

가장 주의할 점은 클로저는 **생성될 때마다 선언적 환경을 기억해야 한다.**<br/>
따라서 이를 위한 메모리 공간을 필요로 한다.

이는 **성능에도 영향**을 미칠 수 있기 때문에 주의가 필요하다.

### 이벤트 루프와 비동기 통신의 이해

> **프로세스**

- 프로그램이 메모리에 올라가 실행된 작업 단위

> **스레드**

- 하나의 프로세스 내에서 동시에 여러 작업을 수행하기 위해 실행되는 작은 작업 단위
- 각 스레드는 스택을 제외한 나머지 메모리 공간을 공유한다.

> **왜 싱글 스레드로 구현되었을까?**

- 내부적으로 처리가 복잡하다.
- 동시에 서로 같은 자원에 접근하여 Race Condition이 발생할 수 있다.
- 또한 하나의 스레드에서 문제가 발생했을때 자원을 공유하는 다른 스레드에도 문제가 발생할 수 있다.
  - 예를 들어, 여러 스레드가 하나의 DOM을 조작한다면…. 타이밍 이슈와 같은 문제들이 발생할 수 있고, 이를 동기화하는데에는 큰 비용이 들 것임…
- 따라서 Call Stack이 하나인 싱글 스레드 형태로 구현되었고, 이 한계를 극복하기 위해 비동기 처리를 수행한다.

> **동기**

- 한 번에 하나씩 순서대로 작업을 처리한다. (직렬 방식)
- 하나의 큰 작업이 수행될 경우, 블로킹이 발생한다.

> **비동기**

- 요청한 즉시 결과가 주어지지 않을 수도 있고 응답이 언제 올지 알 수 없지만, 여러 작업을 동시에 수행할 수 있다. (병렬 방식)

> **이벤트 루프**

- 자바스크립트의 비동기 실행을 돕기 위해 만들어진 장치
- 이벤트 루프의 역할은 다음과 같다.
  - Call Stack이 비어있는지 확인
  - 태스크 큐에 대기중인 함수들이 존재하는지 확인하고 꺼내와 실행시킴

> **비동기 함수는 누가 실행할까?**

- 자바스크립트 메인 스레드가 아닌, 태스크큐가 할당되는 별도의 스레드에서 수행된다.
  - 브라우저
  - Node.js
- 즉, 코드 실행 자체는 메인 스레드에서 이루어지지만, 외부 Web API 등은 모두 자바스크립트 코드 외부에서 실행되고 콜백이 태스크 큐로 들어간다.
  - 이렇게 태스크 큐로 들어간 콜백은 이벤트 루프가 Call Stack이 비어있는지 확인후 가져와 실행하는 것이다.

> **태스크 큐와 마이크로 태스크 큐**

- 마이크로 태스크 큐는 태스크 큐와 다른 태스크를 처리하는 또다른 큐이다.
- 마이크로 테스크 큐는 태스크 큐보다 우선권을 갖는다.
- 대표적으로는 Promise를 처리한다.

> **렌더링은 언제 일어날까?**

- 태스크 큐의 작업들을 실행하기 전에, 마이크로 태스크 큐에 쌓인 작업을 먼저 실행한다.
- 그리고 태스크 큐의 작업을 실행하기 전, 렌더링이 일어난다.
- 따라서 마이크로 태스크 큐의 작업이 끝날 때마다 한번씩 렌더링을 할 기회를 얻게 된다.

### 리액트에서 자주 사용하는 자바스크립트 문법

> **바벨 (Babel)**

- 자바스크립트의 최신 문법을 다양한 브라우저에서도 일관적으로 지원할 수 있도록 코드를 트랜스파일한다.
- 트랜스파일 vs 컴파일
  - 트랜스파일 : 언어를 다른 언어로 바꿔주는 것
    - JavaScript → 바이트 코드
    - TypeScript → JavaScript
  - 컴파일 : 언어를 기계가 알 수 있게끔 로우 레벨 언어로 바꿔준 개념입니다. → C언어

> **구조 분해 할당**

- 배열 또는 객체의 값을 말 그대로 분해해 개별 변수에 즉시 할당하는 것이다.
- 배열 구조 분해 할당은 ES6, 객체 구조 분해 할당은 그 이후 ECMA 2018에 추가되었다.

> **useState는 왜 객체 구조 분해 할당이 아닌 배열 구조 분해 할당을 사용했을까?**

- 추측이지만, 배열 구조 분해 할당은 구조 분해 할당으로 변수에 이름을 지정하는 것이 자유롭지만, 객체 구조 분해 할당은 그렇지 않다. (`속성: 변수 이름` 형태로 수정해야 해서 번거로움)

> **전개(spread) 연산자 (`…`)**

- 마찬가지로 배열은 ES6, 객체는 그 이후 ECMA 2018에 추가되었다.

> **객체의 구조 분해 할당과 스프레드 연산자**

- 두 경우 모두. 트랜스파일 이후 번들링 크기가 상대적으로 커지기 때문에 잘 검토하여 사용할 필요가 있다.
  - 객체의 속성을 모두 가져와 변수와 매칭하는 작업에서 코드가 매우 커진다.

> **배열 고차함수**

- map
- filter
- reduce
- forEach

> **삼항 조건 연산자**

- 조건부 렌더링을 위해 많이 쓰인다.
  - 하지만 겹쳐 쓸 경우, 결과 예측이 어려울 수 있어 중첩해서 사용하지 않는 편이 좋다.

### 선택이 아닌 필수, 타입스크립트

> **unknown**

- `unknown`은 어떠한 값이든 할당할 수 있는 top type이다.
- 하지만 `any`와 다르게, **타입을 좁혀야** 사용이 가능하다.
- 반대되는 bottom type으로는 어떠한 것도 할당할 수 없는 never가 있다.

> **타입 가드**

- 타입을 사용할 때는 최대한 타입을 좁혀 사용하는 것이 좋다.
- 이를 도와주는 것이 `타입 가드`이다.
- 타입 가드는 다음과 같이 사용할 수 있다.

  - `instanceof`

    - 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있다.

      ```tsx
      class Error {
        /* ... */
      }

      if (e instanceof Error) {
        /* do something */
      }
      ```

  - `typeof`

    - 특정 요소에 대해 자료형을 확인하는데 사용할 수 있다.

      ```tsx
      if (typeof (value === 'number')) {
        /* do something */
      }
      ```

  - `in`

    - 어떤 객체에 키가 존재하는지 확인하는 용도로 사용된다.
    - property in object

      ```tsx
      interface Student {
        age: number;
        score: number;
      }

      function doStudy(person: Student) {
        if ('age' in person) {
          /* do something */
        }
      }
      ```

> **제네릭**

- 다양한 타입에 대응할 수 있도록 도와주는 도구
- 제네릭을 통해 기본값을 선언해 준다면 undefined로 값을 추론해버리는 문제를 방지할 수 있다.

> 인덱스 시그니처

- 객체의 키를 정의하는 방식
- 키에 원하는 타입을 부여할 수 있다.
